import { parse, basename, resolve, normalize, join, dirname, relative, extname } from 'pathe';
import consola from 'consola';
import { existsSync, readdirSync, lstatSync, promises } from 'fs';
import hash from 'hash-sum';
import { getContext } from 'unctx';
import satisfies from 'semver/functions/satisfies.js';
import { pathToFileURL } from 'url';
import { interopDefault } from 'mlly';
import jiti from 'jiti';
import { globby } from 'globby';
import defu from 'defu';
import { applyDefaults } from 'untyped';
import lodashTemplate from 'lodash.template';
import { camelCase, kebabCase, pascalCase } from 'scule';
import * as rc from 'rc9';
import { NuxtConfigSchema } from '@nuxt/schema';
import dotenv from 'dotenv';
import { resolvePackageJSON, readPackageJSON } from 'pkg-types';

function chainFn(base, fn) {
  if (typeof fn !== "function") {
    return base;
  }
  return function(...args) {
    if (typeof base !== "function") {
      return fn.apply(this, args);
    }
    let baseResult = base.apply(this, args);
    if (baseResult === void 0) {
      [baseResult] = args;
    }
    const fnResult = fn.call(this, baseResult, ...Array.prototype.slice.call(args, 1));
    if (fnResult === void 0) {
      return baseResult;
    }
    return fnResult;
  };
}

const nuxtCtx = getContext("nuxt");
const useNuxt = nuxtCtx.use;

function addTemplate(_template) {
  const nuxt = useNuxt();
  const template = normalizeTemplate(_template);
  nuxt.options.build.templates = nuxt.options.build.templates.filter((p) => normalizeTemplate(p).filename !== template.filename);
  nuxt.options.build.templates.push(template);
  return template;
}
function normalizeTemplate(template) {
  if (!template) {
    throw new Error("Invalid template: " + JSON.stringify(template));
  }
  if (typeof template === "string") {
    template = { src: template };
  } else {
    template = { ...template };
  }
  if (template.src) {
    if (!existsSync(template.src)) {
      throw new Error("Template not found: " + template.src);
    }
    if (!template.filename) {
      const srcPath = parse(template.src);
      template.filename = template.fileName || `${basename(srcPath.dir)}.${srcPath.name}.${hash(template.src)}${srcPath.ext}`;
    }
  }
  if (!template.src && !template.getContents) {
    throw new Error("Invalid template. Either getContents or src options should be provided: " + JSON.stringify(template));
  }
  if (!template.filename) {
    throw new Error("Invalid template. Either filename should be provided: " + JSON.stringify(template));
  }
  if (!template.dst) {
    const nuxt = useNuxt();
    template.dst = resolve(nuxt.options.buildDir, template.filename);
  }
  return template;
}

function addServerMiddleware(middleware) {
  useNuxt().options.serverMiddleware.push(middleware);
}

async function checkNuxtCompatibility(constraints, nuxt = useNuxt()) {
  const issues = [];
  if (constraints.nuxt) {
    const nuxtVersion = getNuxtVersion(nuxt);
    const nuxtSemanticVersion = nuxtVersion.split("-").shift();
    if (!satisfies(nuxtSemanticVersion, constraints.nuxt)) {
      issues.push({
        name: "nuxt",
        message: `Nuxt version \`${constraints.nuxt}\` is required but currently using \`${nuxtVersion}\``
      });
    }
  }
  if (isNuxt2(nuxt)) {
    const bridgeRequirement = constraints?.bridge;
    const hasBridge = !!nuxt.options.bridge;
    if (bridgeRequirement === true && !hasBridge) {
      issues.push({
        name: "bridge",
        message: "Nuxt bridge is required"
      });
    } else if (bridgeRequirement === false && hasBridge) {
      issues.push({
        name: "bridge",
        message: "Nuxt bridge is not supported"
      });
    }
  }
  await nuxt.callHook("kit:compatibility", constraints, issues);
  issues.toString = () => issues.map((issue) => ` - [${issue.name}] ${issue.message}`).join("\n");
  return issues;
}
async function assertNuxtCompatibility(constraints, nuxt = useNuxt()) {
  const issues = await checkNuxtCompatibility(constraints, nuxt);
  if (issues.length) {
    throw new Error("Nuxt compatibility issues found:\n" + issues.toString());
  }
  return true;
}
async function hasNuxtCompatibility(constraints, nuxt = useNuxt()) {
  const issues = await checkNuxtCompatibility(constraints, nuxt);
  return !issues.length;
}
function isNuxt2(nuxt = useNuxt()) {
  return getNuxtVersion(nuxt).startsWith("2.");
}
function isNuxt3(nuxt = useNuxt()) {
  return getNuxtVersion(nuxt).startsWith("3.");
}
function getNuxtVersion(nuxt = useNuxt()) {
  const version = (nuxt?._version || nuxt?.version || nuxt?.constructor?.version || "").replace(/^v/g, "");
  if (!version) {
    throw new Error("Cannot determine nuxt version! Is currect instance passed?");
  }
  return version;
}

function normalizePlugin(plugin) {
  if (typeof plugin === "string") {
    plugin = { src: plugin };
  } else {
    plugin = { ...plugin };
  }
  if (!plugin.src) {
    throw new Error("Invalid plugin. src option is required: " + JSON.stringify(plugin));
  }
  plugin.src = normalize(plugin.src);
  if (plugin.ssr) {
    plugin.mode = "server";
  }
  if (!plugin.mode) {
    const [, mode = "all"] = plugin.src.match(/\.(server|client)(\.\w+)*$/) || [];
    plugin.mode = mode;
  }
  return plugin;
}
function addPlugin(_plugin, opts = {}) {
  const nuxt = useNuxt();
  const plugin = normalizePlugin(_plugin);
  nuxt.options.plugins = nuxt.options.plugins.filter((p) => normalizePlugin(p).src !== plugin.src);
  nuxt.options.plugins[opts.append ? "push" : "unshift"](plugin);
  return plugin;
}
function addPluginTemplate(plugin, opts = {}) {
  if (typeof plugin === "string") {
    plugin = { src: plugin };
  }
  plugin.src = addTemplate(plugin).dst;
  return addPlugin(plugin, opts);
}

const _require = jiti(process.cwd(), { interopDefault: true });
function isNodeModules(id) {
  return /[/\\]node_modules[/\\]/.test(id);
}
function clearRequireCache(id) {
  if (isNodeModules(id)) {
    return;
  }
  const entry = getRequireCacheItem(id);
  if (!entry) {
    delete _require.cache[id];
    return;
  }
  if (entry.parent) {
    entry.parent.children = entry.parent.children.filter((e) => e.id !== id);
  }
  for (const child of entry.children) {
    clearRequireCache(child.id);
  }
  delete _require.cache[id];
}
function scanRequireTree(id, files = /* @__PURE__ */ new Set()) {
  if (isNodeModules(id) || files.has(id)) {
    return files;
  }
  const entry = getRequireCacheItem(id);
  if (!entry) {
    files.add(id);
    return files;
  }
  files.add(entry.id);
  for (const child of entry.children) {
    scanRequireTree(child.id, files);
  }
  return files;
}
function getRequireCacheItem(id) {
  try {
    return _require.cache[id];
  } catch (e) {
  }
}
function requireModulePkg(id, opts = {}) {
  return requireModule(join(id, "package.json"), opts);
}
function resolveModule(id, opts = {}) {
  return normalize(_require.resolve(id, {
    paths: [].concat(global.__NUXT_PREPATHS__, opts.paths, process.cwd(), global.__NUXT_PATHS__).filter(Boolean)
  }));
}
function tryResolveModule(path, opts = {}) {
  try {
    return resolveModule(path, opts);
  } catch (error) {
    if (error.code !== "MODULE_NOT_FOUND") {
      throw error;
    }
  }
}
function requireModule(id, opts = {}) {
  const resolvedPath = resolveModule(id, opts);
  if (opts.clearCache && !isNodeModules(id)) {
    clearRequireCache(resolvedPath);
  }
  const requiredModule = _require(resolvedPath);
  return requiredModule;
}
function importModule(id, opts = {}) {
  const resolvedPath = resolveModule(id, opts);
  if (opts.interopDefault !== false) {
    return import(pathToFileURL(resolvedPath).href).then(interopDefault);
  }
  return import(pathToFileURL(resolvedPath).href);
}
function tryImportModule(id, opts = {}) {
  try {
    return importModule(id, opts).catch(() => void 0);
  } catch {
  }
}
function tryRequireModule(id, opts = {}) {
  try {
    return requireModule(id, opts);
  } catch (e) {
  }
}

function resolvePath(path, opts = {}) {
  if (existsSyncSensitive(path)) {
    return path;
  }
  let resolvedPath;
  if (opts.alias) {
    resolvedPath = resolveAlias(path, opts.alias);
  }
  resolvedPath = resolve(opts.base || ".", resolvedPath);
  const resolvedPathFiles = readdirSync(dirname(resolvedPath));
  let isDirectory = false;
  if (existsSyncSensitive(resolvedPath, resolvedPathFiles)) {
    isDirectory = lstatSync(resolvedPath).isDirectory();
    if (!isDirectory) {
      return resolvedPath;
    }
  }
  for (const ext of opts.extensions) {
    const resolvedPathwithExt = resolvedPath + ext;
    if (!isDirectory && existsSyncSensitive(resolvedPathwithExt, resolvedPathFiles)) {
      return resolvedPathwithExt;
    }
    const resolvedPathwithIndex = join(resolvedPath, "index" + ext);
    if (isDirectory && existsSyncSensitive(resolvedPathwithIndex)) {
      return resolvedPathwithIndex;
    }
  }
  if (isDirectory) {
    return resolvedPath;
  }
  throw new Error(`Cannot resolve "${path}" from "${resolvedPath}"`);
}
function existsSyncSensitive(path, files) {
  if (!existsSync(path)) {
    return false;
  }
  const _files = files || readdirSync(dirname(path));
  return _files.includes(basename(path));
}
function resolveAlias(path, alias) {
  for (const key in alias) {
    if (key === "@" && !path.startsWith("@/")) {
      continue;
    }
    if (path.startsWith(key)) {
      path = alias[key] + path.slice(key.length);
    }
  }
  return path;
}
function tryResolvePath(path, opts = {}) {
  try {
    return resolvePath(path, opts);
  } catch (e) {
  }
}
async function resolveFiles(path, pattern) {
  const files = await globby(pattern, {
    cwd: path,
    followSymbolicLinks: true
  });
  return files.map((p) => resolve(path, p));
}

async function installModule(nuxtModule, inlineOptions, nuxt = useNuxt()) {
  if (nuxtModule?._version || nuxtModule?.version || nuxtModule?.constructor?.version || "") {
    [nuxt, nuxtModule] = [nuxtModule, inlineOptions];
    inlineOptions = {};
    console.warn(new Error("`installModule` is being called with old signature!"));
  }
  if (typeof nuxtModule === "string") {
    const _src = resolveModule(resolveAlias(nuxtModule, nuxt.options.alias), { paths: nuxt.options.modulesDir });
    const isESM = _src.endsWith(".mjs");
    nuxtModule = isESM ? await importModule(_src) : requireModule(_src);
  }
  if (typeof nuxtModule !== "function") {
    throw new TypeError("Nuxt module should be a function: " + nuxtModule);
  }
  await nuxtModule.call(useModuleContainer(), inlineOptions, nuxt);
}

const MODULE_CONTAINER_KEY = "__module_container__";
function useModuleContainer(nuxt = useNuxt()) {
  if (nuxt[MODULE_CONTAINER_KEY]) {
    return nuxt[MODULE_CONTAINER_KEY];
  }
  async function requireModule(moduleOpts) {
    let src, inlineOptions;
    if (typeof moduleOpts === "string") {
      src = moduleOpts;
    } else if (Array.isArray(moduleOpts)) {
      [src, inlineOptions] = moduleOpts;
    } else if (typeof moduleOpts === "object") {
      if (moduleOpts.src || moduleOpts.handler) {
        src = moduleOpts.src || moduleOpts.handler;
        inlineOptions = moduleOpts.options;
      } else {
        src = moduleOpts;
      }
    } else {
      src = moduleOpts;
    }
    await installModule(src, inlineOptions, nuxt);
  }
  nuxt[MODULE_CONTAINER_KEY] = {
    nuxt,
    options: nuxt.options,
    ready() {
      return Promise.resolve();
    },
    addVendor() {
    },
    requireModule,
    addModule: requireModule,
    addServerMiddleware,
    addTemplate(template) {
      if (typeof template === "string") {
        template = { src: template };
      }
      if (template.write === void 0) {
        template.write = true;
      }
      return addTemplate(template);
    },
    addPlugin(pluginTemplate) {
      return addPluginTemplate(pluginTemplate);
    },
    addLayout(tmpl, name) {
      const { filename, src } = addTemplate(tmpl);
      const layoutName = name || parse(src).name;
      const layout = nuxt.options.layouts[layoutName];
      if (layout) {
        consola.warn(`Duplicate layout registration, "${layoutName}" has been registered as "${layout}"`);
      }
      nuxt.options.layouts[layoutName] = `./${filename}`;
      if (name === "error") {
        this.addErrorLayout(filename);
      }
    },
    addErrorLayout(dst) {
      const relativeBuildDir = relative(nuxt.options.rootDir, nuxt.options.buildDir);
      nuxt.options.ErrorPage = `~/${relativeBuildDir}/${dst}`;
    },
    extendBuild(fn) {
      nuxt.options.build.extend = chainFn(nuxt.options.build.extend, fn);
    },
    extendRoutes(fn) {
      if (isNuxt2(nuxt)) {
        nuxt.options.router.extendRoutes = chainFn(nuxt.options.router.extendRoutes, fn);
      } else {
        nuxt.hook("pages:extend", async (pages, ...args) => {
          const maybeRoutes = await fn(pages, ...args);
          if (maybeRoutes) {
            console.warn("[kit] [compat] Using `extendRoutes` in Nuxt 3 needs to directly modify first argument instead of returning updated routes. Skipping extended routes.");
          }
        });
      }
    }
  };
  return nuxt[MODULE_CONTAINER_KEY];
}

async function compileTemplate(template, ctx) {
  const data = { ...ctx, options: template.options };
  if (template.src) {
    try {
      const srcContents = await promises.readFile(template.src, "utf-8");
      return lodashTemplate(srcContents, {})(data);
    } catch (err) {
      console.error("Error compiling template: ", template);
      throw err;
    }
  }
  if (template.getContents) {
    return template.getContents(data);
  }
  throw new Error("Invalid template: " + JSON.stringify(template));
}
const serialize = (data) => JSON.stringify(data, null, 2).replace(/"{(.+)}"/g, "$1");
const importName = (src) => `${camelCase(basename(src, extname(src))).replace(/[^a-zA-Z?\d\s:]/g, "")}_${hash(src)}`;
const importSources = (sources, { lazy = false } = {}) => {
  if (!Array.isArray(sources)) {
    sources = [sources];
  }
  return sources.map((src) => {
    if (lazy) {
      return `const ${importName(src)} = () => import('${src}' /* webpackChunkName: '${src}' */)`;
    }
    return `import ${importName(src)} from '${src}'`;
  }).join("\n");
};
const templateUtils = { serialize, importName, importSources };

function defineNuxtModule(definition) {
  if (typeof definition === "function") {
    definition = definition(useNuxt());
    consola.warn("Module definition as function is deprecated and will be removed in the future versions", definition);
  }
  if (!definition.meta) {
    definition.meta = {};
  }
  if (!definition.meta.configKey) {
    definition.meta.name = definition.meta.name || definition.name;
    definition.meta.configKey = definition.meta.configKey || definition.configKey || definition.meta.name;
  }
  function getOptions(inlineOptions, nuxt = useNuxt()) {
    const configKey = definition.meta.configKey || definition.meta.name;
    const _defaults = typeof definition.defaults === "function" ? definition.defaults(nuxt) : definition.defaults;
    let _options = defu(inlineOptions, nuxt.options[configKey], _defaults);
    if (definition.schema) {
      _options = applyDefaults(definition.schema, _options);
    }
    return Promise.resolve(_options);
  }
  async function normalizedModule(inlineOptions, nuxt) {
    if (!nuxt) {
      nuxt = useNuxt() || this.nuxt;
    }
    const uniqueKey = definition.meta.name || definition.meta.configKey;
    if (uniqueKey) {
      nuxt.options._requiredModules = nuxt.options._requiredModules || {};
      if (nuxt.options._requiredModules[uniqueKey]) {
        return;
      }
      nuxt.options._requiredModules[uniqueKey] = true;
    }
    if (definition.meta.compatibility) {
      const issues = await checkNuxtCompatibility(definition.meta.compatibility, nuxt);
      if (issues.length) {
        consola.warn(`Module \`${definition.meta.name}\` is disabled due to incompatibility issues:
${issues.toString()}`);
        return;
      }
    }
    nuxt2Shims(nuxt);
    const _options = await getOptions(inlineOptions, nuxt);
    if (definition.hooks) {
      nuxt.hooks.addHooks(definition.hooks);
    }
    await definition.setup?.call(null, _options, nuxt);
  }
  normalizedModule.getMeta = () => Promise.resolve(definition.meta);
  normalizedModule.getOptions = getOptions;
  return normalizedModule;
}
const NUXT2_SHIMS_KEY = "__nuxt2_shims_key__";
function nuxt2Shims(nuxt) {
  if (!isNuxt2(nuxt) || nuxt[NUXT2_SHIMS_KEY]) {
    return;
  }
  nuxt[NUXT2_SHIMS_KEY] = true;
  nuxt.hooks = nuxt;
  if (!nuxtCtx.use()) {
    nuxtCtx.set(nuxt);
    nuxt.hook("close", () => nuxtCtx.unset());
  }
  let virtualTemplates;
  nuxt.hook("builder:prepared", (_builder, buildOptions) => {
    virtualTemplates = buildOptions.templates.filter((t) => t.getContents);
    for (const template of virtualTemplates) {
      buildOptions.templates.splice(buildOptions.templates.indexOf(template), 1);
    }
  });
  nuxt.hook("build:templates", async (templates) => {
    const context = {
      nuxt,
      utils: templateUtils,
      app: {
        dir: nuxt.options.srcDir,
        extensions: nuxt.options.extensions,
        plugins: nuxt.options.plugins,
        templates: [
          ...templates.templatesFiles,
          ...virtualTemplates
        ],
        templateVars: templates.templateVars
      }
    };
    for await (const template of virtualTemplates) {
      const contents = await compileTemplate({ ...template, src: "" }, context);
      await promises.mkdir(dirname(template.dst), { recursive: true });
      await promises.writeFile(template.dst, contents);
    }
  });
}

async function setupDotenv(options) {
  const targetEnv = options.env ?? process.env;
  const env = await loadDotenv({
    rootDir: options.rootDir,
    fileName: options.fileName ?? ".env",
    env: targetEnv,
    expand: options.expand ?? true
  });
  for (const key in env) {
    if (!key.startsWith("_") && targetEnv[key] === void 0) {
      targetEnv[key] = env[key];
    }
  }
  return env;
}
async function loadDotenv(opts) {
  const env = /* @__PURE__ */ Object.create(null);
  const dotenvFile = resolve(opts.rootDir, opts.fileName);
  if (existsSync(dotenvFile)) {
    const parsed = dotenv.parse(await promises.readFile(dotenvFile, "utf-8"));
    Object.assign(env, parsed);
  }
  if (!opts.env._applied) {
    Object.assign(env, opts.env);
    env._applied = true;
  }
  if (opts.expand) {
    expand(env);
  }
  return env;
}
function expand(target, source = {}, parse = (v) => v) {
  function getValue(key) {
    return source[key] !== void 0 ? source[key] : target[key];
  }
  function interpolate(value, parents = []) {
    if (typeof value !== "string") {
      return value;
    }
    const matches = value.match(/(.?\${?(?:[a-zA-Z0-9_:]+)?}?)/g) || [];
    return parse(matches.reduce((newValue, match) => {
      const parts = /(.?)\${?([a-zA-Z0-9_:]+)?}?/g.exec(match);
      const prefix = parts[1];
      let value2, replacePart;
      if (prefix === "\\") {
        replacePart = parts[0];
        value2 = replacePart.replace("\\$", "$");
      } else {
        const key = parts[2];
        replacePart = parts[0].substring(prefix.length);
        if (parents.includes(key)) {
          console.warn(`Please avoid recursive environment variables ( loop: ${parents.join(" > ")} > ${key} )`);
          return "";
        }
        value2 = getValue(key);
        value2 = interpolate(value2, [...parents, key]);
      }
      return value2 !== void 0 ? newValue.replace(replacePart, value2) : newValue;
    }, value));
  }
  for (const key in target) {
    target[key] = interpolate(getValue(key));
  }
}

async function loadNuxtConfig(opts) {
  const rootDir = resolve(process.cwd(), opts.rootDir || ".");
  if (opts.dotenv !== false) {
    await setupDotenv({ rootDir, ...opts.dotenv });
  }
  const nuxtConfigFile = tryResolveModule(resolve(rootDir, opts.configFile || "nuxt.config"));
  let nuxtConfig = {};
  if (nuxtConfigFile && existsSync(nuxtConfigFile)) {
    nuxtConfig = requireModule(nuxtConfigFile, { clearCache: true });
    if (typeof nuxtConfig === "function") {
      nuxtConfig = await nuxtConfig(opts);
    }
    nuxtConfig = { ...nuxtConfig };
    nuxtConfig._nuxtConfigFile = nuxtConfigFile;
    nuxtConfig._nuxtConfigFiles = Array.from(scanRequireTree(nuxtConfigFile));
  }
  nuxtConfig = defu(opts.config, nuxtConfig, rc.read({ name: ".nuxtrc", dir: rootDir }), rc.readUser(".nuxtrc"));
  if (!nuxtConfig.rootDir) {
    nuxtConfig.rootDir = rootDir;
  }
  return applyDefaults(NuxtConfigSchema, nuxtConfig);
}

async function loadNuxt(opts) {
  const resolveOpts = { paths: opts.rootDir };
  const nearestNuxtPkg = await Promise.all(["nuxt3", "nuxt-edge", "nuxt"].map((pkg2) => resolvePackageJSON(pkg2, { url: opts.rootDir }).catch(() => null))).then((r) => r.filter(Boolean).sort((a, b) => b.length - a.length)[0]);
  if (!nearestNuxtPkg) {
    throw new Error(`Cannot find any nuxt version from ${opts.rootDir}`);
  }
  const pkg = await readPackageJSON(nearestNuxtPkg);
  const majorVersion = parseInt((pkg.version || "").split(".")[0]);
  if (majorVersion === 3) {
    const { loadNuxt: loadNuxt3 } = await importModule("nuxt3", resolveOpts);
    const nuxt2 = await loadNuxt3(opts);
    return nuxt2;
  }
  const { loadNuxt: loadNuxt2 } = await tryImportModule("nuxt-edge", resolveOpts) || await importModule("nuxt", resolveOpts);
  const nuxt = await loadNuxt2({
    rootDir: opts.rootDir,
    for: opts.dev ? "dev" : "build",
    configOverrides: opts.config,
    ready: opts.ready,
    envConfig: opts.dotenv
  });
  return nuxt;
}
async function buildNuxt(nuxt) {
  const resolveOpts = { paths: nuxt.options.rootDir };
  if (nuxt.options._majorVersion === 3) {
    const { build: build2 } = await importModule("nuxt3", resolveOpts);
    return build2(nuxt);
  }
  const { build } = await tryImportModule("nuxt-edge", resolveOpts) || await tryImportModule("nuxt", resolveOpts);
  return build(nuxt);
}

function extendWebpackConfig(fn, options = {}) {
  const nuxt = useNuxt();
  if (options.dev === false && nuxt.options.dev) {
    return;
  }
  if (options.build === false && nuxt.options.build) {
    return;
  }
  nuxt.hook("webpack:config", (configs) => {
    if (options.server !== false) {
      const config = configs.find((i) => i.name === "server");
      if (config) {
        fn(config);
      }
    }
    if (options.client !== false) {
      const config = configs.find((i) => i.name === "client");
      if (config) {
        fn(config);
      }
    }
    if (options.modern !== false) {
      const config = configs.find((i) => i.name === "modern");
      if (config) {
        fn(config);
      }
    }
  });
}
function extendViteConfig(fn, options = {}) {
  const nuxt = useNuxt();
  if (options.dev === false && nuxt.options.dev) {
    return;
  }
  if (options.build === false && nuxt.options.build) {
    return;
  }
  nuxt.hook("vite:extend", ({ config }) => fn(config));
}
function addWebpackPlugin(plugin, options) {
  extendWebpackConfig((config) => {
    config.plugins = config.plugins || [];
    config.plugins.push(plugin);
  }, options);
}
function addVitePlugin(plugin, options) {
  extendViteConfig((config) => {
    config.plugins = config.plugins || [];
    config.plugins.push(plugin);
  }, options);
}

async function addComponentsDir(dir) {
  const nuxt = useNuxt();
  await assertNuxtCompatibility({ nuxt: ">=2.13" }, nuxt);
  nuxt.options.components = nuxt.options.components || [];
  nuxt.hook("components:dirs", (dirs) => {
    dirs.push(dir);
  });
}
async function addComponent(opts) {
  const nuxt = useNuxt();
  await assertNuxtCompatibility({ nuxt: ">=2.13" }, nuxt);
  nuxt.options.components = nuxt.options.components || [];
  const component = {
    export: opts.export || "default",
    chunkName: "components/" + kebabCase(opts.name),
    global: opts.global ?? false,
    kebabName: kebabCase(opts.name || ""),
    pascalName: pascalCase(opts.name || ""),
    prefetch: false,
    preload: false,
    shortPath: opts.filePath,
    async: false,
    level: 0,
    asyncImport: `() => import('${opts.filePath}').then(r => r['${opts.export || "default"}'])`,
    import: `require('${opts.filePath}')['${opts.export || "default"}']`,
    ...opts
  };
  nuxt.hook("components:extend", (components) => {
    const existingComponent = components.find((c) => c.pascalName === component.pascalName || c.kebabName === component.kebabName);
    if (existingComponent) {
      const name = existingComponent.pascalName || existingComponent.kebabName;
      console.warn(`Overriding ${name} component.`);
      Object.assign(existingComponent, component);
    } else {
      components.push(component);
    }
  });
}

function extendPages(cb) {
  const nuxt = useNuxt();
  if (isNuxt2(nuxt)) {
    nuxt.hook("build:extendRoutes", cb);
  } else {
    nuxt.hook("pages:extend", cb);
  }
}

export { addComponent, addComponentsDir, addPlugin, addPluginTemplate, addServerMiddleware, addTemplate, addVitePlugin, addWebpackPlugin, assertNuxtCompatibility, buildNuxt, checkNuxtCompatibility, clearRequireCache, compileTemplate, defineNuxtModule, extendPages, extendViteConfig, extendWebpackConfig, getNuxtVersion, getRequireCacheItem, hasNuxtCompatibility, importModule, installModule, isNodeModules, isNuxt2, isNuxt3, loadNuxt, loadNuxtConfig, normalizePlugin, normalizeTemplate, nuxtCtx, requireModule, requireModulePkg, resolveAlias, resolveFiles, resolveModule, scanRequireTree, templateUtils, tryImportModule, tryRequireModule, tryResolveModule, tryResolvePath, useModuleContainer, useNuxt };
