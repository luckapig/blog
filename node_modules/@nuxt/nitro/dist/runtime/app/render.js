"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderMiddleware = renderMiddleware;

var _vueBundleRenderer = require("vue-bundle-renderer");

var _devalue = _interopRequireDefault(require("@nuxt/devalue"));

var _config = require("./config");

var _paths = require("./paths");

var _documentTemplate = _interopRequireDefault(require("#build/views/document.template.mjs"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const STATIC_ASSETS_BASE = process.env.NUXT_STATIC_BASE + "/" + process.env.NUXT_STATIC_VERSION;
const NUXT_NO_SSR = process.env.NUXT_NO_SSR;
const PAYLOAD_JS = "/payload.js";
const getClientManifest = cachedImport(() => Promise.resolve().then(() => require("#build/dist/server/client.manifest.mjs")));
const getSSRApp = !process.env.NUXT_NO_SSR && cachedImport(() => Promise.resolve().then(() => require("#build/dist/server/server.mjs")));
const getSSRRenderer = cachedResult(async () => {
  const clientManifest = await getClientManifest();

  if (!clientManifest) {
    throw new Error("client.manifest is not available");
  }

  const createSSRApp = await getSSRApp();

  if (!createSSRApp) {
    throw new Error("Server bundle is not available");
  }

  const {
    renderToString: renderToString2
  } = await Promise.resolve().then(() => require("#nitro-renderer"));
  return (0, _vueBundleRenderer.createRenderer)(createSSRApp, {
    clientManifest,
    renderToString: renderToString2,
    publicPath: (0, _paths.buildAssetsURL)()
  }).renderToString;
});
const getSPARenderer = cachedResult(async () => {
  const clientManifest = await getClientManifest();
  return ssrContext => {
    ssrContext.nuxt = {
      serverRendered: false,
      config: _config.publicConfig
    };
    let entryFiles = Object.values(clientManifest).filter(fileValue => fileValue.isEntry);

    if ("all" in clientManifest && "initial" in clientManifest) {
      entryFiles = clientManifest.initial.map(file => ({
        file
      }));
    }

    return {
      html: '<div id="__nuxt"></div>',
      renderResourceHints: () => "",
      renderStyles: () => entryFiles.flatMap(({
        css
      }) => css).filter(css => css != null).map(file => `<link rel="stylesheet" href="${(0, _paths.buildAssetsURL)(file)}">`).join(""),
      renderScripts: () => entryFiles.map(({
        file
      }) => {
        const isMJS = !file.endsWith(".js");
        return `<script ${isMJS ? 'type="module"' : ""} src="${(0, _paths.buildAssetsURL)(file)}"><\/script>`;
      }).join("")
    };
  };
});

function renderToString(ssrContext) {
  const getRenderer = NUXT_NO_SSR || ssrContext.noSSR ? getSPARenderer : getSSRRenderer;
  return getRenderer().then(renderToString2 => renderToString2(ssrContext));
}

async function renderMiddleware(req, res) {
  let url = req.url;
  let isPayloadReq = false;

  if (url.startsWith(STATIC_ASSETS_BASE) && url.endsWith(PAYLOAD_JS)) {
    isPayloadReq = true;
    url = url.slice(STATIC_ASSETS_BASE.length, url.length - PAYLOAD_JS.length) || "/";
  }

  const ssrContext = {
    url,
    req,
    res,
    runtimeConfig: {
      private: _config.privateConfig,
      public: _config.publicConfig
    },
    noSSR: req.spa || req.headers["x-nuxt-no-ssr"],
    ...(req.context || {})
  };
  const rendered = await renderToString(ssrContext);

  if (ssrContext.error) {
    throw ssrContext.error;
  }

  if (ssrContext.redirected || res.writableEnded) {
    return;
  }

  if (ssrContext.nuxt.hooks) {
    await ssrContext.nuxt.hooks.callHook("app:rendered");
  }

  const payload = ssrContext.payload || ssrContext.nuxt;

  if (process.env.NUXT_FULL_STATIC) {
    payload.staticAssetsBase = STATIC_ASSETS_BASE;
  }

  let data;

  if (isPayloadReq) {
    data = renderPayload(payload, url);
    res.setHeader("Content-Type", "text/javascript;charset=UTF-8");
  } else {
    data = await renderHTML(payload, rendered, ssrContext);
    res.setHeader("Content-Type", "text/html;charset=UTF-8");
  }

  const error = ssrContext.nuxt && ssrContext.nuxt.error;
  res.statusCode = error ? error.statusCode : 200;
  res.end(data, "utf-8");
}

async function renderHTML(payload, rendered, ssrContext) {
  const state = `<script>window.__NUXT__=${(0, _devalue.default)(payload)}<\/script>`;
  const html = rendered.html;

  if ("renderMeta" in ssrContext) {
    rendered.meta = await ssrContext.renderMeta();
  }

  const {
    htmlAttrs = "",
    bodyAttrs = "",
    headAttrs = "",
    headTags = "",
    bodyScriptsPrepend = "",
    bodyScripts = ""
  } = rendered.meta || {};
  return (0, _documentTemplate.default)({
    HTML_ATTRS: htmlAttrs,
    HEAD_ATTRS: headAttrs,
    HEAD: headTags + rendered.renderResourceHints() + rendered.renderStyles() + (ssrContext.styles || ""),
    BODY_ATTRS: bodyAttrs,
    APP: bodyScriptsPrepend + html + state + rendered.renderScripts() + bodyScripts
  });
}

function renderPayload(payload, url) {
  return `__NUXT_JSONP__("${url}", ${(0, _devalue.default)(payload)})`;
}

function _interopDefault(e) {
  return e && typeof e === "object" && "default" in e ? e.default : e;
}

function cachedImport(importer) {
  return cachedResult(() => importer().then(_interopDefault));
}

function cachedResult(fn) {
  let res = null;
  return () => {
    if (res === null) {
      res = fn().catch(err => {
        res = null;
        throw err;
      });
    }

    return res;
  };
}