import { NestedHooks, Hookable } from 'hookable';
import { Preset } from 'unenv';
import { Nuxt, NuxtHooks, NuxtOptions } from '@nuxt/schema';
import { PluginVisualizerOptions } from 'rollup-plugin-visualizer';
import { NodeFileTraceOptions } from '@vercel/nft';
import * as h3 from 'h3';
import { Middleware } from 'h3';
import { InputOptions, OutputOptions } from 'rollup';
import { Loader } from 'esbuild';
import { FilterPattern } from '@rollup/pluginutils';
import { Worker } from 'worker_threads';
import { ListenOptions, Listener } from 'listhen';

interface NodeExternalsOptions {
    inline?: string[];
    external?: string[];
    outDir?: string;
    trace?: boolean;
    traceOptions?: NodeFileTraceOptions;
    moduleDirectories?: string[];
    /** additional packages to include in `.output/server/node_modules` */
    traceInclude?: string[];
}

interface StorageOptions {
    mounts: {
        [path: string]: {
            driver: 'fs' | 'http' | 'memory';
            driverOptions?: Record<string, any>;
        };
    };
}

interface AssetOptions {
    inline: Boolean;
    dirs: {
        [assetdir: string]: {
            dir: string;
            meta?: boolean;
        };
    };
}

interface ServerMiddleware {
    route: string;
    /**
     * @deprecated use route
     */
    path?: string;
    handle?: Middleware | string;
    /**
     * @deprecated use handle
     */
    handler?: Middleware | string;
    lazy?: boolean;
    promisify?: boolean;
}
declare function scanMiddleware(serverDir: string, onChange?: (results: ServerMiddleware[], event: 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir', file: string) => void): Promise<ServerMiddleware[]>;
declare function resolveMiddleware(nuxt: Nuxt): {
    middleware: ServerMiddleware[];
    legacyMiddleware: ServerMiddleware[];
};

declare type RollupConfig = InputOptions & {
    output: OutputOptions;
};

declare type Options = {
    include?: FilterPattern;
    exclude?: FilterPattern;
    sourceMap?: boolean;
    minify?: boolean;
    target?: string | string[];
    jsxFactory?: string;
    jsxFragment?: string;
    define?: {
        [k: string]: string;
    };
    /**
     * Use this tsconfig file instead
     * Disable it by setting to `false`
     */
    tsconfig?: string | false;
    /**
     * Map extension to esbuild loader
     * Note that each entry (the extension) needs to start with a dot
     */
    loaders?: {
        [ext: string]: Loader | false;
    };
};

interface NitroHooks {
    'nitro:document': (htmlTemplate: {
        src: string;
        contents: string;
        dst: string;
    }) => void;
    'nitro:rollup:before': (context: NitroContext) => void | Promise<void>;
    'nitro:compiled': (context: NitroContext) => void;
    'nitro:generate': (context: NitroContext) => void | Promise<void>;
    'close': () => void;
}
interface NitroContext {
    alias: Record<string, string>;
    timing: boolean;
    inlineDynamicImports: boolean;
    minify: boolean;
    sourceMap: boolean;
    externals: boolean | NodeExternalsOptions;
    analyze: false | PluginVisualizerOptions;
    entry: string;
    node: boolean;
    preset: string;
    rollupConfig?: RollupConfig;
    esbuild?: {
        options?: Options;
    };
    experiments?: {
        wasm?: boolean;
    };
    commands: {
        preview: string | ((config: NitroContext) => string);
        deploy: string | ((config: NitroContext) => string);
    };
    moduleSideEffects: string[];
    renderer: string;
    serveStatic: boolean;
    middleware: ServerMiddleware[];
    scannedMiddleware: ServerMiddleware[];
    hooks: NestedHooks<NitroHooks>;
    nuxtHooks: NestedHooks<NuxtHooks>;
    ignore: string[];
    env: Preset;
    vfs: Record<string, string>;
    output: {
        dir: string;
        serverDir: string;
        publicDir: string;
    };
    storage: StorageOptions;
    assets: AssetOptions;
    _nuxt: {
        majorVersion: number;
        dev: boolean;
        ssr: boolean;
        rootDir: string;
        srcDir: string;
        buildDir: string;
        generateDir: string;
        publicDir: string;
        serverDir: string;
        baseURL: string;
        buildAssetsDir: string;
        isStatic: boolean;
        fullStatic: boolean;
        staticAssets: any;
        modulesDir: string[];
        runtimeConfig: {
            public: any;
            private: any;
        };
    };
    _internal: {
        runtimeDir: string;
        hooks: Hookable<NitroHooks>;
    };
}
declare type DeepPartial<T> = T extends Record<string, any> ? {
    [P in keyof T]?: DeepPartial<T[P]> | T[P];
} : T;
interface NitroInput extends DeepPartial<NitroContext> {
}
declare type NitroPreset = NitroInput | ((input: NitroInput) => NitroInput);
declare function getNitroContext(nuxtOptions: NuxtOptions, input: NitroInput): NitroContext;

declare function prepare(nitroContext: NitroContext): Promise<void>;
declare function generate(nitroContext: NitroContext): Promise<void>;
declare function build(nitroContext: NitroContext): Promise<void | {
    entry: string;
}>;
declare function writeTypes(nitroContext: NitroContext): Promise<void>;

interface NitroWorker {
    worker: Worker;
    address: string;
}
declare function createDevServer(nitroContext: NitroContext): {
    reload: () => Promise<void>;
    listen: (port: ListenOptions['port'], opts?: Partial<ListenOptions>) => Promise<Listener>;
    app: h3.App;
    close: () => Promise<void>;
    watch: () => void;
    setLegacyMiddleware: (input: Middleware) => void;
    setDevMiddleware: (input: Middleware) => void;
};

declare const wpfs: any;

export { NitroContext, NitroHooks, NitroInput, NitroPreset, NitroWorker, ServerMiddleware, build, createDevServer, generate, getNitroContext, prepare, resolveMiddleware, scanMiddleware, wpfs, writeTypes };
