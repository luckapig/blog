import { join, resolve, dirname, isAbsolute } from 'pathe';
import pify from 'pify';
import webpack from 'webpack';
import Glob from 'glob';
import webpackDevMiddleware from 'webpack-dev-middleware';
import webpackHotMiddleware from 'webpack-hot-middleware';
import VirtualModulesPlugin from 'webpack-virtual-modules';
import consola from 'consola';
import { joinURL } from 'ufo';
import { createUnplugin } from 'unplugin';
import { createFsFromVolume, Volume } from 'memfs';
import querystring from 'querystring';
import { BundleAnalyzerPlugin } from 'webpack-bundle-analyzer';
import { cloneDeep, defaults, merge, uniq } from 'lodash-es';
import TimeFixPlugin from 'time-fix-plugin';
import WebpackBar from 'webpackbar';
import FriendlyErrorsWebpackPlugin from '@nuxt/friendly-errors-webpack-plugin';
import esbuildLoader from 'esbuild-loader';
import MiniCssExtractPlugin from 'mini-css-extract-plugin';
import CssMinimizerPlugin from 'css-minimizer-webpack-plugin';
import fs from 'fs';
import { createCommonJS } from 'mlly';
import createResolver from 'postcss-import-resolver';
import { requireModule } from '@nuxt/kit';
import VueLoaderPlugin from 'vue-loader/dist/pluginWebpack5.js';
import hash from 'hash-sum';
import fse from 'fs-extra';

const VITE_ASSET_RE = /^export default ["'](__VITE_ASSET.*)["']$/;
const DynamicBasePlugin = createUnplugin(function(options) {
  return {
    name: "nuxt:dynamic-base-path",
    resolveId(id) {
      if (id.startsWith("/__NUXT_BASE__")) {
        return id.replace("/__NUXT_BASE__", "");
      }
      return null;
    },
    enforce: "post",
    transform(code, id) {
      if (options.globalPublicPath && id.includes("entry.ts")) {
        code = `import { joinURL } from "ufo";${options.globalPublicPath} = joinURL(NUXT_BASE, NUXT_CONFIG.app.buildAssetsDir);` + code;
      }
      const assetId = code.match(VITE_ASSET_RE);
      if (assetId) {
        code = `import { joinURL } from "ufo";export default joinURL(NUXT_BASE, NUXT_CONFIG.app.buildAssetsDir, "${assetId[1]}".replace("/__NUXT_BASE__", ""));`;
      }
      if (code.includes("NUXT_BASE") && !code.includes("const NUXT_BASE =")) {
        code = "const NUXT_BASE = NUXT_CONFIG.app.cdnURL || NUXT_CONFIG.app.baseURL;" + code;
        if (options.env === "dev") {
          code = `const NUXT_CONFIG = { app: ${JSON.stringify(options.devAppConfig)} };` + code;
        } else if (options.env === "server") {
          code = 'import NUXT_CONFIG from "#config";' + code;
        } else {
          code = "const NUXT_CONFIG = __NUXT__.config;" + code;
        }
      }
      if (id === "vite/preload-helper") {
        code = code.replace(/const base = ['"]\/__NUXT_BASE__\/['"]/, 'import { joinURL } from "ufo";const base = joinURL(NUXT_BASE, NUXT_CONFIG.app.buildAssetsDir);');
      }
      code = code.replace(/from *['"]\/__NUXT_BASE__(\/[^'"]*)['"]/g, 'from "$1"');
      for (const delimiter of ["`", '"', "'"]) {
        const delimiterRE = new RegExp(`${delimiter}([^${delimiter}]*)\\/__NUXT_BASE__\\/([^${delimiter}]*)${delimiter}`, "g");
        code = code.replace(delimiterRE, "`$1${NUXT_BASE}$2`");
      }
      return code;
    }
  };
});

function createMFS() {
  const fs = createFsFromVolume(new Volume());
  const _fs = { ...fs };
  _fs.join = join;
  _fs.exists = (p) => Promise.resolve(_fs.existsSync(p));
  _fs.readFile = pify(_fs.readFile);
  return _fs;
}

function createWebpackConfigContext({ nuxt }) {
  return {
    nuxt,
    options: nuxt.options,
    config: {},
    name: "base",
    isDev: nuxt.options.dev,
    isServer: false,
    isClient: false,
    isModern: void 0,
    isLegacy: false,
    alias: {},
    transpile: []
  };
}
function applyPresets(ctx, presets) {
  if (!Array.isArray(presets)) {
    presets = [presets];
  }
  for (const preset of presets) {
    if (Array.isArray(preset)) {
      preset[0](ctx, preset[1]);
    } else {
      preset(ctx);
    }
  }
}
function fileName(ctx, key) {
  const { options } = ctx;
  let fileName2 = options.build.filenames[key];
  if (typeof fileName2 === "function") {
    fileName2 = fileName2(ctx);
  }
  if (typeof fileName2 === "string" && options.dev) {
    const hash = /\[(chunkhash|contenthash|hash)(?::(\d+))?]/.exec(fileName2);
    if (hash) {
      consola.warn(`Notice: Please do not use ${hash[1]} in dev mode to prevent memory leak`);
    }
  }
  return fileName2;
}
function getWebpackConfig(ctx) {
  const { options, config } = ctx;
  const builder = {};
  const loaders = [];
  const { extend } = options.build;
  if (typeof extend === "function") {
    const extendedConfig = extend.call(builder, config, { loaders, ...ctx }) || config;
    const pragma = /@|#/;
    const { devtool } = extendedConfig;
    if (typeof devtool === "string" && pragma.test(devtool)) {
      extendedConfig.devtool = devtool.replace(pragma, "");
      consola.warn(`devtool has been normalized to ${extendedConfig.devtool} as webpack documented value`);
    }
    return extendedConfig;
  }
  return cloneDeep(config);
}

function assets(ctx) {
  const { options } = ctx;
  ctx.config.module.rules.push({
    test: /\.(png|jpe?g|gif|svg|webp)$/i,
    use: [{
      loader: "url-loader",
      options: {
        ...options.build.loaders.imgUrl,
        name: fileName(ctx, "img")
      }
    }]
  }, {
    test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/i,
    use: [{
      loader: "url-loader",
      options: {
        ...options.build.loaders.fontUrl,
        name: fileName(ctx, "font")
      }
    }]
  }, {
    test: /\.(webm|mp4|ogv)$/i,
    use: [{
      loader: "file-loader",
      options: {
        ...options.build.loaders.file,
        name: fileName(ctx, "video")
      }
    }]
  });
}

class WarningIgnorePlugin {
  constructor(filter) {
    this.filter = filter;
  }
  apply(compiler) {
    compiler.hooks.done.tap("warnfix-plugin", (stats) => {
      stats.compilation.warnings = stats.compilation.warnings.filter(this.filter);
    });
  }
}

function base(ctx) {
  applyPresets(ctx, [
    baseAlias,
    baseConfig,
    basePlugins,
    baseResolve
  ]);
}
function baseConfig(ctx) {
  const { options } = ctx;
  ctx.config = {
    name: ctx.name,
    entry: { app: [resolve(options.appDir, "entry")] },
    module: { rules: [] },
    plugins: [],
    externals: [],
    optimization: {
      ...options.build.optimization,
      minimizer: []
    },
    experiments: {},
    mode: ctx.isDev ? "development" : "production",
    cache: getCache(ctx),
    output: getOutput(ctx),
    stats: "none",
    ...ctx.config
  };
}
function basePlugins(ctx) {
  const { config, options, nuxt } = ctx;
  if (options.dev) {
    config.plugins.push(new TimeFixPlugin());
  }
  config.plugins.push(...options.build.plugins || []);
  config.plugins.push(new WarningIgnorePlugin(getWarningIgnoreFilter(ctx)));
  config.plugins.push(new webpack.DefinePlugin(getEnv(ctx)));
  if (ctx.isServer || ctx.isDev && !options.build.quiet && options.build.friendlyErrors) {
    ctx.config.plugins.push(new FriendlyErrorsWebpackPlugin({
      clearConsole: false,
      reporter: "consola",
      logLevel: "ERROR"
    }));
  }
  const colors = {
    client: "green",
    server: "orange",
    modern: "blue"
  };
  config.plugins.push(new WebpackBar({
    name: ctx.name,
    color: colors[ctx.name],
    reporters: ["stats"],
    stats: !ctx.isDev,
    reporter: {
      change: (_, { shortPath }) => {
        if (!ctx.isServer) {
          nuxt.callHook("bundler:change", shortPath);
        }
      },
      done: ({ state }) => {
        if (state.hasErrors) {
          nuxt.callHook("bundler:error");
        } else {
          consola.success(`${state.name} ${state.message}`);
        }
      },
      allDone: () => {
        nuxt.callHook("bundler:done");
      },
      progress({ statesArray }) {
        nuxt.callHook("bundler:progress", statesArray);
      }
    }
  }));
}
function baseAlias(ctx) {
  const { options } = ctx;
  ctx.alias = {
    "#app": options.appDir,
    "#build/plugins": resolve(options.buildDir, "plugins", ctx.isClient ? "client" : "server"),
    "#build": options.buildDir,
    ...options.alias,
    ...ctx.alias
  };
}
function baseResolve(ctx) {
  const { options, config } = ctx;
  const webpackModulesDir = ["node_modules"].concat(options.modulesDir);
  config.resolve = {
    extensions: [".wasm", ".mjs", ".js", ".ts", ".json", ".vue", ".jsx", ".tsx"],
    alias: ctx.alias,
    modules: webpackModulesDir,
    fullySpecified: false,
    ...config.resolve
  };
  config.resolveLoader = {
    modules: webpackModulesDir,
    ...config.resolveLoader
  };
}
function getCache(ctx) {
  const { options } = ctx;
  if (!options.dev) {
    return false;
  }
}
function getOutput(ctx) {
  const { options } = ctx;
  return {
    path: resolve(options.buildDir, "dist", ctx.isServer ? "server" : "client"),
    filename: fileName(ctx, "app"),
    chunkFilename: fileName(ctx, "chunk"),
    publicPath: joinURL(options.app.baseURL, options.app.buildAssetsDir)
  };
}
function getWarningIgnoreFilter(ctx) {
  const { options } = ctx;
  const filters = [
    (warn) => warn.name === "ModuleDependencyWarning" && warn.message.includes("export 'default'") && warn.message.includes("nuxt_plugin_"),
    ...options.build.warningIgnoreFilters || []
  ];
  return (warn) => !filters.some((ignoreFilter) => ignoreFilter(warn));
}
function getEnv(ctx) {
  const { options } = ctx;
  const _env = {
    "process.env.NODE_ENV": JSON.stringify(ctx.config.mode),
    "process.mode": JSON.stringify(ctx.config.mode),
    "process.dev": options.dev,
    "process.static": options.target === "static",
    "process.target": JSON.stringify(options.target),
    "process.env.VUE_ENV": JSON.stringify(ctx.name),
    "process.browser": ctx.isClient,
    "process.client": ctx.isClient,
    "process.server": ctx.isServer,
    "process.modern": ctx.isModern
  };
  if (options.build.aggressiveCodeRemoval) {
    _env["typeof process"] = JSON.stringify(ctx.isServer ? "object" : "undefined");
    _env["typeof window"] = _env["typeof document"] = JSON.stringify(!ctx.isServer ? "object" : "undefined");
  }
  Object.entries(options.env).forEach(([key, value]) => {
    const isNative = ["boolean", "number"].includes(typeof value);
    _env["process.env." + key] = isNative ? value : JSON.stringify(value);
  });
  return _env;
}

function esbuild(ctx) {
  const { config } = ctx;
  const target = ctx.isServer ? "es2019" : "chrome85";
  config.optimization.minimizer.push(new esbuildLoader.ESBuildMinifyPlugin());
  config.module.rules.push({
    test: /\.m?[jt]s$/i,
    loader: "esbuild-loader",
    exclude: (file) => {
      file = file.split("node_modules", 2)[1];
      if (!file) {
        return false;
      }
      return !ctx.transpile.some((module) => module.test(file));
    },
    resolve: {
      fullySpecified: false
    },
    options: {
      loader: "ts",
      target
    }
  }, {
    test: /\.m?[jt]sx$/,
    loader: "esbuild-loader",
    options: {
      loader: "tsx",
      target
    }
  });
}

function pug(ctx) {
  ctx.config.module.rules.push({
    test: /\.pug$/i,
    oneOf: [
      {
        resourceQuery: /^\?vue/i,
        use: [{
          loader: "pug-plain-loader",
          options: ctx.options.build.loaders.pugPlain
        }]
      },
      {
        use: [
          "raw-loader",
          {
            loader: "pug-plain-loader",
            options: ctx.options.build.loaders.pugPlain
          }
        ]
      }
    ]
  });
}

const isPureObject = (obj) => obj !== null && !Array.isArray(obj) && typeof obj === "object";
const orderPresets = {
  cssnanoLast(names) {
    const nanoIndex = names.indexOf("cssnano");
    if (nanoIndex !== names.length - 1) {
      names.push(names.splice(nanoIndex, 1)[0]);
    }
    return names;
  },
  autoprefixerLast(names) {
    const nanoIndex = names.indexOf("autoprefixer");
    if (nanoIndex !== names.length - 1) {
      names.push(names.splice(nanoIndex, 1)[0]);
    }
    return names;
  },
  autoprefixerAndCssnanoLast(names) {
    return orderPresets.cssnanoLast(orderPresets.autoprefixerLast(names));
  }
};
let _postcssConfigFileWarningShown;
function postcssConfigFileWarning() {
  if (_postcssConfigFileWarningShown) {
    return;
  }
  consola.warn("Please use `build.postcss` in your nuxt.config.js instead of an external config file. Support for such files will be removed in Nuxt 3 as they remove all defaults set by Nuxt and can cause severe problems with features like alias resolving inside your CSS.");
  _postcssConfigFileWarningShown = true;
}
class PostcssConfig {
  constructor(nuxt) {
    this.nuxt = nuxt;
    this.options = nuxt.options;
  }
  get postcssOptions() {
    return this.options.build.postcss.postcssOptions;
  }
  get postcssImportAlias() {
    const alias = { ...this.options.alias };
    for (const key in alias) {
      if (key.startsWith("~")) {
        continue;
      }
      const newKey = "~" + key;
      if (!alias[newKey]) {
        alias[newKey] = alias[key];
      }
    }
    return alias;
  }
  get defaultConfig() {
    const { dev, srcDir, rootDir, modulesDir } = this.options;
    return {
      sourceMap: this.options.build.cssSourceMap,
      plugins: {
        "postcss-import": {
          resolve: createResolver({
            alias: this.postcssImportAlias,
            modules: [srcDir, rootDir, ...modulesDir]
          })
        },
        "postcss-url": {},
        autoprefixer: {},
        cssnano: dev ? false : {
          preset: ["default", {
            minifyFontValues: { removeQuotes: false }
          }]
        }
      },
      order: "autoprefixerAndCssnanoLast"
    };
  }
  searchConfigFile() {
    const { srcDir, rootDir } = this.options;
    for (const dir of [srcDir, rootDir]) {
      for (const file of [
        "postcss.config.js",
        ".postcssrc.js",
        ".postcssrc",
        ".postcssrc.json",
        ".postcssrc.yaml"
      ]) {
        const configFile = resolve(dir, file);
        if (fs.existsSync(configFile)) {
          postcssConfigFileWarning();
          return configFile;
        }
      }
    }
  }
  getConfigFile() {
    const loaderConfig = this.postcssOptions && this.postcssOptions.config;
    const postcssConfigFile = loaderConfig || this.searchConfigFile();
    if (typeof postcssConfigFile === "string") {
      return postcssConfigFile;
    }
  }
  sortPlugins({ plugins, order }) {
    const names = Object.keys(plugins);
    if (typeof order === "string") {
      order = orderPresets[order];
    }
    return typeof order === "function" ? order(names, orderPresets) : order || names;
  }
  loadPlugins(config) {
    if (!isPureObject(config.plugins)) {
      return;
    }
    const cjs = createCommonJS(import.meta.url);
    config.plugins = this.sortPlugins(config).map((pluginName) => {
      const pluginFn = requireModule(pluginName, { paths: [cjs.__dirname] });
      const pluginOptions = config.plugins[pluginName];
      if (!pluginOptions || typeof pluginFn !== "function") {
        return null;
      }
      return pluginFn(pluginOptions);
    }).filter(Boolean);
  }
  config() {
    if (!this.options.build.postcss) {
      return false;
    }
    const configFile = this.getConfigFile();
    if (configFile) {
      return {
        postcssOptions: {
          config: configFile
        },
        sourceMap: this.options.build.cssSourceMap
      };
    }
    let postcssOptions = cloneDeep(this.postcssOptions);
    if (isPureObject(postcssOptions)) {
      if (Array.isArray(postcssOptions.plugins)) {
        defaults(postcssOptions, this.defaultConfig);
      } else {
        postcssOptions = merge({}, this.defaultConfig, postcssOptions);
        this.loadPlugins(postcssOptions);
      }
      delete this.options.build.postcss.order;
      return {
        sourceMap: this.options.build.cssSourceMap,
        ...this.options.build.postcss,
        postcssOptions
      };
    }
  }
}

function style(ctx) {
  applyPresets(ctx, [
    loaders,
    extractCSS,
    minimizer
  ]);
}
function minimizer(ctx) {
  const { options, config } = ctx;
  if (options.build.optimizeCSS && Array.isArray(config.optimization.minimizer)) {
    config.optimization.minimizer.push(new CssMinimizerPlugin({
      ...options.build.optimizeCSS
    }));
  }
}
function extractCSS(ctx) {
  const { options, config } = ctx;
  if (options.build.extractCSS) {
    config.plugins.push(new MiniCssExtractPlugin({
      filename: fileName(ctx, "css"),
      chunkFilename: fileName(ctx, "css"),
      ...options.build.extractCSS
    }));
  }
}
function loaders(ctx) {
  const { config, options } = ctx;
  config.module.rules.push(createdStyleRule("css", /\.css$/i, null, ctx));
  config.module.rules.push(createdStyleRule("postcss", /\.p(ost)?css$/i, null, ctx));
  const lessLoader = { loader: "less-loader", options: options.build.loaders.less };
  config.module.rules.push(createdStyleRule("less", /\.less$/i, lessLoader, ctx));
  const sassLoader = { loader: "sass-loader", options: options.build.loaders.sass };
  config.module.rules.push(createdStyleRule("sass", /\.sass$/i, sassLoader, ctx));
  const scssLoader = { loader: "sass-loader", options: options.build.loaders.scss };
  config.module.rules.push(createdStyleRule("scss", /\.scss$/i, scssLoader, ctx));
  const stylusLoader = { loader: "stylus-loader", options: options.build.loaders.stylus };
  config.module.rules.push(createdStyleRule("stylus", /\.styl(us)?$/i, stylusLoader, ctx));
}
function createdStyleRule(lang, test, processorLoader, ctx) {
  const { options } = ctx;
  const styleLoaders = [
    createPostcssLoadersRule(ctx),
    processorLoader,
    createStyleResourcesLoaderRule(lang, options.build.styleResources, options.rootDir)
  ].filter(Boolean);
  options.build.loaders.css.importLoaders = options.build.loaders.cssModules.importLoaders = styleLoaders.length;
  const cssLoaders = createCssLoadersRule(ctx, options.build.loaders.css);
  const cssModuleLoaders = createCssLoadersRule(ctx, options.build.loaders.cssModules);
  return {
    test,
    oneOf: [
      {
        resourceQuery: /module/,
        use: cssModuleLoaders.concat(styleLoaders)
      },
      {
        use: cssLoaders.concat(styleLoaders)
      }
    ]
  };
}
function createCssLoadersRule(ctx, cssLoaderOptions) {
  const { options } = ctx;
  const cssLoader = { loader: "css-loader", options: cssLoaderOptions };
  if (options.build.extractCSS) {
    if (ctx.isServer) {
      return [cssLoader];
    }
    return [
      {
        loader: MiniCssExtractPlugin.loader
      },
      cssLoader
    ];
  }
  return [
    {
      loader: "vue-style-loader",
      options: options.build.loaders.vueStyle
    },
    cssLoader
  ];
}
function createStyleResourcesLoaderRule(styleLang, styleResources, rootDir) {
  if (!styleResources[styleLang]) {
    return;
  }
  return {
    loader: "style-resources-loader",
    options: {
      patterns: Array.from(styleResources[styleLang]).map((p) => resolve(rootDir, p)),
      ...styleResources.options
    }
  };
}
function createPostcssLoadersRule(ctx) {
  const { options, nuxt } = ctx;
  if (!options.build.postcss) {
    return;
  }
  const postcssConfig = new PostcssConfig(nuxt);
  const config = postcssConfig.config();
  if (!config) {
    return;
  }
  return {
    loader: "postcss-loader",
    options: config
  };
}

const validate = (compiler) => {
  if (compiler.options.target !== "node") {
    consola.warn('webpack config `target` should be "node".');
  }
  if (!compiler.options.externals) {
    consola.info("It is recommended to externalize dependencies in the server build for better build performance.");
  }
};
const isJSRegExp = /\.[cm]?js(\?[^.]+)?$/;
const isJS = (file) => isJSRegExp.test(file);
const extractQueryPartJS = (file) => isJSRegExp.exec(file)[1];
const isCSS = (file) => /\.css(\?[^.]+)?$/.test(file);
const isHotUpdate = (file) => file.includes("hot-update");

class VueSSRClientPlugin {
  constructor(options = {}) {
    this.options = Object.assign({
      filename: null
    }, options);
  }
  apply(compiler) {
    compiler.hooks.afterEmit.tap("VueSSRClientPlugin", async (compilation) => {
      const stats = compilation.getStats().toJson();
      const allFiles = uniq(stats.assets.map((a) => a.name)).filter((file) => !isHotUpdate(file));
      const initialFiles = uniq(Object.keys(stats.entrypoints).map((name) => stats.entrypoints[name].assets).reduce((files, entryAssets) => files.concat(entryAssets.map((entryAsset) => entryAsset.name)), []).filter((file) => isJS(file) || isCSS(file))).filter((file) => !isHotUpdate(file));
      const asyncFiles = allFiles.filter((file) => isJS(file) || isCSS(file)).filter((file) => !initialFiles.includes(file)).filter((file) => !isHotUpdate(file));
      const assetsMapping = {};
      stats.assets.filter(({ name }) => isJS(name)).filter(({ name }) => !isHotUpdate(name)).forEach(({ name, chunkNames }) => {
        const componentHash = hash(chunkNames.join("|"));
        if (!assetsMapping[componentHash]) {
          assetsMapping[componentHash] = [];
        }
        assetsMapping[componentHash].push(name);
      });
      const manifest = {
        publicPath: stats.publicPath,
        all: allFiles,
        initial: initialFiles,
        async: asyncFiles,
        modules: {},
        assetsMapping
      };
      const { entrypoints, namedChunkGroups } = stats;
      const assetModules = stats.modules.filter((m) => m.assets.length);
      const fileToIndex = (file) => manifest.all.indexOf(file);
      stats.modules.forEach((m) => {
        if (m.chunks.length === 1) {
          const [cid] = m.chunks;
          const chunk = stats.chunks.find((c) => c.id === cid);
          if (!chunk || !chunk.files) {
            return;
          }
          const id = m.identifier.replace(/\s\w+$/, "");
          const filesSet = new Set(chunk.files.map(fileToIndex).filter((i) => i !== -1));
          for (const chunkName of chunk.names) {
            if (!entrypoints[chunkName]) {
              const chunkGroup = namedChunkGroups[chunkName];
              if (chunkGroup) {
                for (const asset of chunkGroup.assets) {
                  filesSet.add(fileToIndex(asset.name));
                }
              }
            }
          }
          const files = Array.from(filesSet);
          manifest.modules[hash(id)] = files;
          if (Array.isArray(m.modules)) {
            for (const concatenatedModule of m.modules) {
              const id2 = hash(concatenatedModule.identifier.replace(/\s\w+$/, ""));
              if (!manifest.modules[id2]) {
                manifest.modules[id2] = files;
              }
            }
          }
          assetModules.forEach((m2) => {
            if (m2.chunks.includes(cid)) {
              files.push.apply(files, m2.assets.map(fileToIndex));
            }
          });
        }
      });
      const src = JSON.stringify(manifest, null, 2);
      await fse.mkdirp(dirname(this.options.filename));
      await fse.writeFile(this.options.filename, src);
      const mjsSrc = "export default " + src;
      await fse.writeFile(this.options.filename.replace(".json", ".mjs"), mjsSrc);
    });
  }
}

class VueSSRServerPlugin {
  constructor(options = {}) {
    this.options = Object.assign({
      filename: null
    }, options);
  }
  apply(compiler) {
    validate(compiler);
    compiler.hooks.make.tap("VueSSRServerPlugin", (compilation) => {
      compilation.hooks.processAssets.tapAsync({
        name: "VueSSRServerPlugin",
        stage: webpack.Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL
      }, (assets, cb) => {
        const stats = compilation.getStats().toJson();
        const [entryName] = Object.keys(stats.entrypoints);
        const entryInfo = stats.entrypoints[entryName];
        if (!entryInfo) {
          return cb();
        }
        const entryAssets = entryInfo.assets.filter((asset) => isJS(asset.name));
        if (entryAssets.length > 1) {
          throw new Error("Server-side bundle should have one single entry file. Avoid using CommonsChunkPlugin in the server config.");
        }
        const [entry] = entryAssets;
        if (!entry || typeof entry.name !== "string") {
          throw new Error(`Entry "${entryName}" not found. Did you specify the correct entry option?`);
        }
        const bundle = {
          entry: entry.name,
          files: {},
          maps: {}
        };
        stats.assets.forEach((asset) => {
          if (isJS(asset.name)) {
            const queryPart = extractQueryPartJS(asset.name);
            if (queryPart !== void 0) {
              bundle.files[asset.name] = asset.name.replace(queryPart, "");
            } else {
              bundle.files[asset.name] = asset.name;
            }
          } else if (asset.name.match(/\.js\.map$/)) {
            bundle.maps[asset.name.replace(/\.map$/, "")] = asset.name;
          } else {
            delete assets[asset.name];
          }
        });
        const src = JSON.stringify(bundle, null, 2);
        assets[this.options.filename] = {
          source: () => src,
          size: () => src.length
        };
        const mjsSrc = "export default " + src;
        assets[this.options.filename.replace(".json", ".mjs")] = {
          source: () => mjsSrc,
          map: () => null,
          size: () => mjsSrc.length
        };
        cb();
      });
    });
  }
}

function vue(ctx) {
  const { options, config } = ctx;
  config.plugins.push(new (VueLoaderPlugin.default || VueLoaderPlugin)());
  config.module.rules.push({
    test: /\.vue$/i,
    loader: "vue-loader",
    options: options.build.loaders.vue
  });
  if (ctx.isClient) {
    config.plugins.push(new VueSSRClientPlugin({
      filename: resolve(options.buildDir, "dist/server", `${ctx.name}.manifest.json`)
    }));
  } else {
    config.plugins.push(new VueSSRServerPlugin({
      filename: `${ctx.name}.manifest.json`
    }));
  }
  config.plugins.push(new webpack.DefinePlugin({
    __VUE_OPTIONS_API__: "true",
    __VUE_PROD_DEVTOOLS__: "false"
  }));
}

function nuxt(ctx) {
  applyPresets(ctx, [
    base,
    assets,
    esbuild,
    pug,
    style,
    vue
  ]);
}

function client(ctx) {
  ctx.name = "client";
  ctx.isClient = true;
  applyPresets(ctx, [
    nuxt,
    clientPlugins,
    clientOptimization,
    clientDevtool,
    clientPerformance,
    clientHMR
  ]);
}
function clientDevtool(ctx) {
  if (!ctx.isDev) {
    ctx.config.devtool = false;
    return;
  }
  const scriptPolicy = getCspScriptPolicy(ctx);
  const noUnsafeEval = scriptPolicy && !scriptPolicy.includes("'unsafe-eval'");
  ctx.config.devtool = noUnsafeEval ? "cheap-module-source-map" : "eval-cheap-module-source-map";
}
function clientPerformance(ctx) {
  ctx.config.performance = {
    maxEntrypointSize: 1e3 * 1024,
    hints: ctx.isDev ? false : "warning",
    ...ctx.config.performance
  };
}
function clientHMR(ctx) {
  const { options, config } = ctx;
  if (!ctx.isDev) {
    return;
  }
  const clientOptions = options.build.hotMiddleware?.client || {};
  const hotMiddlewareClientOptions = {
    reload: true,
    timeout: 3e4,
    path: joinURL(options.app.baseURL, "__webpack_hmr", ctx.name),
    ...clientOptions,
    ansiColors: JSON.stringify(clientOptions.ansiColors || {}),
    overlayStyles: JSON.stringify(clientOptions.overlayStyles || {}),
    name: ctx.name
  };
  const hotMiddlewareClientOptionsStr = querystring.stringify(hotMiddlewareClientOptions);
  const app = config.entry.app;
  app.unshift(`webpack-hot-middleware/client?${hotMiddlewareClientOptionsStr}`);
  config.plugins.push(new webpack.HotModuleReplacementPlugin());
}
function clientOptimization(_ctx) {
}
function clientPlugins(ctx) {
  const { options, config } = ctx;
  if (!ctx.isDev && ctx.name === "client" && options.build.analyze) {
    const statsDir = resolve(options.buildDir, "stats");
    config.plugins.push(new BundleAnalyzerPlugin({
      analyzerMode: "static",
      defaultSizes: "gzip",
      generateStatsFile: true,
      openAnalyzer: !options.build.quiet,
      reportFilename: resolve(statsDir, `${ctx.name}.html`),
      statsFilename: resolve(statsDir, `${ctx.name}.json`),
      ...options.build.analyze
    }));
  }
}
function getCspScriptPolicy(ctx) {
  const { csp } = ctx.options.render;
  if (typeof csp === "object") {
    const { policies = {} } = csp;
    return policies["script-src"] || policies["default-src"] || [];
  }
}

function node(ctx) {
  const { config } = ctx;
  config.target = "node";
  config.node = false;
  config.experiments.outputModule = true;
  config.output = {
    ...config.output,
    chunkFilename: "[name].mjs",
    chunkFormat: "module",
    chunkLoading: "import",
    module: true,
    environment: {
      module: true,
      arrowFunction: true,
      bigIntLiteral: true,
      const: true,
      destructuring: true,
      dynamicImport: true,
      forOf: true
    },
    library: {
      type: "module"
    }
  };
  config.performance = {
    ...config.performance,
    hints: false,
    maxEntrypointSize: Infinity,
    maxAssetSize: Infinity
  };
}

const assetPattern = /\.(png|jpe?g|gif|svg|woff2?|eot|ttf|otf|webp|webm|mp4|ogv)(\?.*)?$/i;
function server(ctx) {
  ctx.name = "server";
  ctx.isServer = true;
  applyPresets(ctx, [
    nuxt,
    node,
    serverStandalone,
    serverPreset,
    serverPlugins
  ]);
  return getWebpackConfig(ctx);
}
function serverPreset(ctx) {
  const { config } = ctx;
  config.output.filename = "server.mjs";
  config.devtool = "cheap-module-source-map";
  config.optimization = {
    splitChunks: false,
    minimize: false
  };
}
function serverStandalone(ctx) {
  const inline = [
    "src/",
    "#app",
    "!",
    "-!",
    "~",
    "@/",
    "#",
    ...ctx.options.build.transpile
  ];
  const external = ["#config"];
  if (!Array.isArray(ctx.config.externals)) {
    return;
  }
  ctx.config.externals.push(({ request }, cb) => {
    if (external.includes(request)) {
      return cb(null, true);
    }
    if (request[0] === "." || isAbsolute(request) || inline.find((prefix) => request.startsWith(prefix)) || assetPattern.test(request)) {
      return cb(null, false);
    }
    return cb(null, true);
  });
}
function serverPlugins(ctx) {
  const { config, options } = ctx;
  if (options.build.serverURLPolyfill) {
    config.plugins.push(new webpack.ProvidePlugin({
      URL: [options.build.serverURLPolyfill, "URL"],
      URLSearchParams: [options.build.serverURLPolyfill, "URLSearchParams"]
    }));
  }
}

const glob = pify(Glob);
class WebpackBundler {
  constructor(nuxt) {
    this.nuxt = nuxt;
    this.plugins = [];
    this.compilers = [];
    this.compilersWatching = [];
    this.devMiddleware = {};
    this.hotMiddleware = {};
    this.middleware = this.middleware.bind(this);
    if (this.nuxt.options.dev) {
      this.mfs = createMFS();
    }
    this.virtualModules = new VirtualModulesPlugin(nuxt.vfs);
    const writeFiles = () => {
      for (const filePath in nuxt.vfs) {
        this.virtualModules.writeModule(filePath, nuxt.vfs[filePath]);
      }
    };
    nuxt.hook("build:compile", ({ compiler }) => {
      if (compiler.name === "server") {
        writeFiles();
      }
    });
    nuxt.hook("app:templatesGenerated", writeFiles);
  }
  getWebpackConfig(name) {
    const ctx = createWebpackConfigContext({ nuxt: this.nuxt });
    if (name === "client") {
      applyPresets(ctx, client);
    } else if (name === "server") {
      applyPresets(ctx, server);
    } else {
      throw new Error(`Unsupported webpack config ${name}`);
    }
    return getWebpackConfig(ctx);
  }
  async build() {
    const { options } = this.nuxt;
    const webpackConfigs = [
      this.getWebpackConfig("client")
    ];
    if (options.ssr) {
      webpackConfigs.push(this.getWebpackConfig("server"));
    }
    await this.nuxt.callHook("webpack:config", webpackConfigs);
    const { styleResources } = this.nuxt.options.build;
    if (styleResources && Object.keys(styleResources).length) {
      consola.warn("Using styleResources without the @nuxtjs/style-resources is not suggested and can lead to severe performance issues.", "Please use https://github.com/nuxt-community/style-resources-module");
      for (const ext of Object.keys(styleResources)) {
        await Promise.all(Array.from(styleResources[ext]).map(async (p) => {
          const styleResourceFiles = await glob(resolve(this.nuxt.options.rootDir, p));
          if (!styleResourceFiles || styleResourceFiles.length === 0) {
            throw new Error(`Style Resource not found: ${p}`);
          }
        }));
      }
    }
    this.compilers = webpackConfigs.map((config) => {
      config.plugins.push(this.virtualModules);
      config.plugins.push(DynamicBasePlugin.webpack({
        env: this.nuxt.options.dev ? "dev" : config.name,
        devAppConfig: this.nuxt.options.app,
        globalPublicPath: "__webpack_public_path__"
      }));
      const compiler = webpack(config);
      if (options.dev) {
        compiler.outputFileSystem = this.mfs;
      }
      return compiler;
    });
    if (options.dev) {
      return Promise.all(this.compilers.map((c) => this.webpackCompile(c)));
    } else {
      for (const c of this.compilers) {
        await this.webpackCompile(c);
      }
    }
  }
  async webpackCompile(compiler) {
    const { name } = compiler.options;
    const { options } = this.nuxt;
    await this.nuxt.callHook("build:compile", { name, compiler });
    compiler.hooks.done.tap("load-resources", async (stats2) => {
      await this.nuxt.callHook("build:compiled", {
        name,
        compiler,
        stats: stats2
      });
      await this.nuxt.callHook("build:resources", this.mfs);
    });
    if (options.dev) {
      if (["client", "modern"].includes(name)) {
        return new Promise((resolve2, reject) => {
          compiler.hooks.done.tap("nuxt-dev", () => {
            resolve2(null);
          });
          compiler.hooks.failed.tap("nuxt-errorlog", (err) => {
            reject(err);
          });
          this.webpackDev(compiler);
        });
      }
      return new Promise((resolve2, reject) => {
        const watching = compiler.watch(options.watchers.webpack, (err) => {
          if (err) {
            return reject(err);
          }
          resolve2(null);
        });
        watching.closeAsync = pify(watching.close);
        this.compilersWatching.push(watching);
      });
    }
    compiler.run = pify(compiler.run);
    const stats = await compiler.run();
    if (stats.hasErrors()) {
      const error = new Error("Nuxt build error");
      if (options.build.quiet === true) {
        error.stack = stats.toString("errors-only");
      }
      throw error;
    }
    await this.nuxt.callHook("build:resources");
  }
  async webpackDev(compiler) {
    consola.debug("Creating webpack middleware...");
    const { name } = compiler.options;
    const buildOptions = this.nuxt.options.build;
    const { client: client2, ...hotMiddlewareOptions } = buildOptions.hotMiddleware || {};
    this.devMiddleware[name] = pify(webpackDevMiddleware(compiler, {
      publicPath: joinURL(this.nuxt.options.app.baseURL, this.nuxt.options.app.buildAssetsDir),
      outputFileSystem: this.mfs,
      stats: "none",
      ...buildOptions.devMiddleware
    }));
    this.devMiddleware[name].close = pify(this.devMiddleware[name].close);
    this.compilersWatching.push(this.devMiddleware[name].context.watching);
    this.hotMiddleware[name] = pify(webpackHotMiddleware(compiler, {
      log: false,
      heartbeat: 1e4,
      path: joinURL(this.nuxt.options.app.baseURL, "__webpack_hmr", name),
      ...hotMiddlewareOptions
    }));
    await this.nuxt.callHook("server:devMiddleware", this.middleware);
  }
  async middleware(req, res, next) {
    if (this.devMiddleware && this.devMiddleware.client) {
      await this.devMiddleware.client(req, res);
    }
    if (this.hotMiddleware && this.hotMiddleware.client) {
      await this.hotMiddleware.client(req, res);
    }
    next();
  }
  async unwatch() {
    await Promise.all(this.compilersWatching.map((watching) => watching.closeAsync()));
  }
  async close() {
    if (this.__closed) {
      return;
    }
    this.__closed = true;
    await this.unwatch();
    for (const devMiddleware of Object.values(this.devMiddleware)) {
      await devMiddleware.close();
    }
    for (const compiler of this.compilers) {
      await new Promise((resolve2) => compiler.close(resolve2));
    }
    if (this.mfs) {
      delete this.mfs;
    }
    delete this.compilers;
    delete this.compilersWatching;
    delete this.devMiddleware;
    delete this.hotMiddleware;
  }
  forGenerate() {
    this.nuxt.options.target = "static";
  }
}
function bundle(nuxt) {
  const bundler = new WebpackBundler(nuxt);
  return bundler.build();
}

export { bundle };
