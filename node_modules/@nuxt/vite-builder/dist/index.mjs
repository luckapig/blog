import * as vite from 'vite';
import { resolve as resolve$2, join, normalize, isAbsolute, dirname as dirname$1 } from 'pathe';
import consola from 'consola';
import { sanitizeFilePath } from 'mlly';
import { joinURL, withoutTrailingSlash, withoutLeadingSlash } from 'ufo';
import vuePlugin from '@vitejs/plugin-vue';
import viteJsxPlugin from '@vitejs/plugin-vue-jsx';
import { transform } from 'esbuild';
import { visualizer } from 'rollup-plugin-visualizer';
import fse from 'fs-extra';
import { createHash } from 'crypto';
import fs, { readdirSync, statSync, promises, existsSync } from 'fs';
import { fileURLToPath, pathToFileURL } from 'url';
import require$$0$1, { dirname, resolve as resolve$3, extname } from 'path';
import require$$0 from 'constants';
import pDebounce from 'p-debounce';
import { resolveModule, requireModule } from '@nuxt/kit';
import { builtinModules } from 'module';
import { isExternal as isExternal$1, ExternalsDefaults } from 'externality';
import createResolver from 'postcss-import-resolver';
import defu from 'defu';

function cacheDirPlugin(rootDir, name) {
  const optimizeCacheDir = resolve$2(rootDir, "node_modules/.cache/vite", name);
  return {
    name: "nuxt:cache-dir",
    configResolved(resolvedConfig) {
      resolvedConfig.optimizeCacheDir = optimizeCacheDir;
    }
  };
}

function analyzePlugin(ctx) {
  return [
    {
      name: "nuxt-analyze-minify",
      async generateBundle(_opts, outputBundle) {
        for (const [_bundleId, bundle] of Object.entries(outputBundle)) {
          if (bundle.type !== "chunk") {
            continue;
          }
          const originalEntries = Object.entries(bundle.modules);
          const minifiedEntries = await Promise.all(originalEntries.map(async ([moduleId, module]) => {
            const { code } = await transform(module.code || "", { minify: true });
            return [moduleId, { ...module, code }];
          }));
          bundle.modules = Object.fromEntries(minifiedEntries);
        }
        return null;
      }
    },
    visualizer({
      ...ctx.nuxt.options.build.analyze,
      filename: ctx.nuxt.options.build.analyze.filename.replace("{name}", "client"),
      title: "Client bundle stats",
      gzipSize: true
    })
  ];
}

const wpfs = {
  ...fse,
  join
};

async function writeManifest(ctx, extraEntries = []) {
  const clientDist = resolve$2(ctx.nuxt.options.buildDir, "dist/client");
  const serverDist = resolve$2(ctx.nuxt.options.buildDir, "dist/server");
  const entries = [
    "@vite/client",
    "entry.mjs",
    ...extraEntries
  ];
  const devClientManifest = {
    publicPath: joinURL(ctx.nuxt.options.app.baseURL, ctx.nuxt.options.app.buildAssetsDir),
    all: entries,
    initial: entries,
    async: [],
    modules: {}
  };
  const clientManifest = ctx.nuxt.options.dev ? devClientManifest : await fse.readJSON(resolve$2(clientDist, "manifest.json"));
  await fse.mkdirp(serverDist);
  await fse.writeFile(resolve$2(serverDist, "client.manifest.json"), JSON.stringify(clientManifest, null, 2), "utf8");
  await fse.writeFile(resolve$2(serverDist, "client.manifest.mjs"), "export default " + JSON.stringify(clientManifest, null, 2), "utf8");
}

function uniq(arr) {
  return Array.from(new Set(arr));
}
const IS_CSS_RE = /\.(?:css|scss|sass|postcss|less|stylus|styl)(\?[^.]+)?$/;
function isCSS(file) {
  return IS_CSS_RE.test(file);
}
function hashId(id) {
  return "$id_" + hash(id);
}
function hash(input, length = 8) {
  return createHash("sha256").update(input).digest("hex").slice(0, length);
}
function readDirRecursively(dir) {
  return readdirSync(dir).reduce((files, file) => {
    const name = join(dir, file);
    const isDirectory2 = statSync(name).isDirectory();
    return isDirectory2 ? [...files, ...readDirRecursively(name)] : [...files, name];
  }, []);
}
async function isDirectory(path) {
  try {
    return (await promises.stat(path)).isDirectory();
  } catch (_err) {
    return false;
  }
}

function devStyleSSRPlugin(options) {
  return {
    name: "nuxt:dev-style-ssr",
    apply: "serve",
    enforce: "post",
    transform(code, id) {
      if (!isCSS(id) || !code.includes("import.meta.hot")) {
        return;
      }
      let moduleId = id;
      if (moduleId.startsWith(options.rootDir)) {
        moduleId = moduleId.slice(options.rootDir.length);
      }
      const selector = joinURL(options.buildAssetsURL, moduleId);
      return code + `
document.querySelectorAll(\`link[href="${selector}"]\`).forEach(i=>i.remove())`;
    }
  };
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var virtualStats = {};

var __importDefault$1 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(virtualStats, "__esModule", { value: true });
virtualStats.VirtualStats = void 0;
const constants_1 = __importDefault$1(require$$0);
class VirtualStats {
    constructor(config) {
        for (const key in config) {
            if (!Object.prototype.hasOwnProperty.call(config, key)) {
                continue;
            }
            this[key] = config[key];
        }
    }
    _checkModeProperty(property) {
        return (this.mode & constants_1.default.S_IFMT) === property;
    }
    isDirectory() {
        return this._checkModeProperty(constants_1.default.S_IFDIR);
    }
    isFile() {
        return this._checkModeProperty(constants_1.default.S_IFREG);
    }
    isBlockDevice() {
        return this._checkModeProperty(constants_1.default.S_IFBLK);
    }
    isCharacterDevice() {
        return this._checkModeProperty(constants_1.default.S_IFCHR);
    }
    isSymbolicLink() {
        return this._checkModeProperty(constants_1.default.S_IFLNK);
    }
    isFIFO() {
        return this._checkModeProperty(constants_1.default.S_IFIFO);
    }
    isSocket() {
        return this._checkModeProperty(constants_1.default.S_IFSOCK);
    }
}
virtualStats.VirtualStats = VirtualStats;

var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const path_1 = __importDefault(require$$0$1);
const virtual_stats_1 = virtualStats;
let inode = 45000000;
function checkActivation(instance) {
    if (!instance._compiler) {
        throw new Error('You must use this plugin only after creating webpack instance!');
    }
}
function getModulePath(filePath, compiler) {
    return path_1.default.isAbsolute(filePath) ? filePath : path_1.default.join(compiler.context, filePath);
}
function createWebpackData(result) {
    return (backendOrStorage) => {
        if (backendOrStorage._data) {
            const curLevelIdx = backendOrStorage._currentLevel;
            const curLevel = backendOrStorage._levels[curLevelIdx];
            return {
                result,
                level: curLevel,
            };
        }
        return [null, result];
    };
}
function getData(storage, key) {
    if (storage._data instanceof Map) {
        return storage._data.get(key);
    }
    else if (storage._data) {
        return storage.data[key];
    }
    else if (storage.data instanceof Map) {
        return storage.data.get(key);
    }
    else {
        return storage.data[key];
    }
}
function setData(backendOrStorage, key, valueFactory) {
    const value = valueFactory(backendOrStorage);
    if (backendOrStorage._data instanceof Map) {
        backendOrStorage._data.set(key, value);
    }
    else if (backendOrStorage._data) {
        backendOrStorage.data[key] = value;
    }
    else if (backendOrStorage.data instanceof Map) {
        backendOrStorage.data.set(key, value);
    }
    else {
        backendOrStorage.data[key] = value;
    }
}
function getStatStorage(fileSystem) {
    if (fileSystem._statStorage) {
        return fileSystem._statStorage;
    }
    else if (fileSystem._statBackend) {
        return fileSystem._statBackend;
    }
    else {
        throw new Error("Couldn't find a stat storage");
    }
}
function getFileStorage(fileSystem) {
    if (fileSystem._readFileStorage) {
        return fileSystem._readFileStorage;
    }
    else if (fileSystem._readFileBackend) {
        return fileSystem._readFileBackend;
    }
    else {
        throw new Error("Couldn't find a readFileStorage");
    }
}
function getReadDirBackend(fileSystem) {
    if (fileSystem._readdirBackend) {
        return fileSystem._readdirBackend;
    }
    else if (fileSystem._readdirStorage) {
        return fileSystem._readdirStorage;
    }
    else {
        throw new Error("Couldn't find a readDirStorage from Webpack Internals");
    }
}
class VirtualModulesPlugin {
    constructor(modules) {
        this._compiler = null;
        this._watcher = null;
        this._staticModules = modules || null;
    }
    writeModule(filePath, contents) {
        if (!this._compiler) {
            throw new Error(`Plugin has not been initialized`);
        }
        checkActivation(this);
        const len = contents ? contents.length : 0;
        const time = Date.now();
        const date = new Date(time);
        const stats = new virtual_stats_1.VirtualStats({
            dev: 8675309,
            nlink: 0,
            uid: 1000,
            gid: 1000,
            rdev: 0,
            blksize: 4096,
            ino: inode++,
            mode: 33188,
            size: len,
            blocks: Math.floor(len / 4096),
            atime: date,
            mtime: date,
            ctime: date,
            birthtime: date,
        });
        const modulePath = getModulePath(filePath, this._compiler);
        if (process.env.WVM_DEBUG)
            console.log(this._compiler.name, 'Write virtual module:', modulePath, contents);
        let finalWatchFileSystem = this._watcher && this._watcher.watchFileSystem;
        while (finalWatchFileSystem && finalWatchFileSystem.wfs) {
            finalWatchFileSystem = finalWatchFileSystem.wfs;
        }
        let finalInputFileSystem = this._compiler.inputFileSystem;
        while (finalInputFileSystem && finalInputFileSystem._inputFileSystem) {
            finalInputFileSystem = finalInputFileSystem._inputFileSystem;
        }
        finalInputFileSystem._writeVirtualFile(modulePath, stats, contents);
        if (finalWatchFileSystem &&
            (finalWatchFileSystem.watcher.fileWatchers.size || finalWatchFileSystem.watcher.fileWatchers.length)) {
            const fileWatchers = finalWatchFileSystem.watcher.fileWatchers instanceof Map
                ? Array.from(finalWatchFileSystem.watcher.fileWatchers.values())
                : finalWatchFileSystem.watcher.fileWatchers;
            for (const fileWatcher of fileWatchers) {
                if (fileWatcher.path === modulePath) {
                    if (process.env.DEBUG)
                        console.log(this._compiler.name, 'Emit file change:', modulePath, time);
                    delete fileWatcher.directoryWatcher._cachedTimeInfoEntries;
                    fileWatcher.directoryWatcher.setFileTime(filePath, time, false, false, null);
                    fileWatcher.emit('change', time, null);
                }
            }
        }
    }
    apply(compiler) {
        this._compiler = compiler;
        const afterEnvironmentHook = () => {
            let finalInputFileSystem = compiler.inputFileSystem;
            while (finalInputFileSystem && finalInputFileSystem._inputFileSystem) {
                finalInputFileSystem = finalInputFileSystem._inputFileSystem;
            }
            if (!finalInputFileSystem._writeVirtualFile) {
                const originalPurge = finalInputFileSystem.purge;
                finalInputFileSystem.purge = () => {
                    originalPurge.apply(finalInputFileSystem, []);
                    if (finalInputFileSystem._virtualFiles) {
                        Object.keys(finalInputFileSystem._virtualFiles).forEach((file) => {
                            const data = finalInputFileSystem._virtualFiles[file];
                            finalInputFileSystem._writeVirtualFile(file, data.stats, data.contents);
                        });
                    }
                };
                finalInputFileSystem._writeVirtualFile = (file, stats, contents) => {
                    const statStorage = getStatStorage(finalInputFileSystem);
                    const fileStorage = getFileStorage(finalInputFileSystem);
                    const readDirStorage = getReadDirBackend(finalInputFileSystem);
                    finalInputFileSystem._virtualFiles = finalInputFileSystem._virtualFiles || {};
                    finalInputFileSystem._virtualFiles[file] = { stats: stats, contents: contents };
                    setData(statStorage, file, createWebpackData(stats));
                    setData(fileStorage, file, createWebpackData(contents));
                    const segments = file.split(/[\\/]/);
                    let count = segments.length - 1;
                    const minCount = segments[0] ? 1 : 0;
                    while (count > minCount) {
                        const dir = segments.slice(0, count).join(path_1.default.sep) || path_1.default.sep;
                        try {
                            finalInputFileSystem.readdirSync(dir);
                        }
                        catch (e) {
                            const time = Date.now();
                            const dirStats = new virtual_stats_1.VirtualStats({
                                dev: 8675309,
                                nlink: 0,
                                uid: 1000,
                                gid: 1000,
                                rdev: 0,
                                blksize: 4096,
                                ino: inode++,
                                mode: 16877,
                                size: stats.size,
                                blocks: Math.floor(stats.size / 4096),
                                atime: time,
                                mtime: time,
                                ctime: time,
                                birthtime: time,
                            });
                            setData(readDirStorage, dir, createWebpackData([]));
                            setData(statStorage, dir, createWebpackData(dirStats));
                        }
                        let dirData = getData(getReadDirBackend(finalInputFileSystem), dir);
                        dirData = dirData[1] || dirData.result;
                        const filename = segments[count];
                        if (dirData.indexOf(filename) < 0) {
                            const files = dirData.concat([filename]).sort();
                            setData(getReadDirBackend(finalInputFileSystem), dir, createWebpackData(files));
                        }
                        else {
                            break;
                        }
                        count--;
                    }
                };
            }
        };
        const afterResolversHook = () => {
            if (this._staticModules) {
                for (const [filePath, contents] of Object.entries(this._staticModules)) {
                    this.writeModule(filePath, contents);
                }
                this._staticModules = null;
            }
        };
        const watchRunHook = (watcher, callback) => {
            this._watcher = watcher.compiler || watcher;
            const virtualFiles = compiler.inputFileSystem._virtualFiles;
            const fts = compiler.fileTimestamps;
            if (virtualFiles && fts && typeof fts.set === 'function') {
                Object.keys(virtualFiles).forEach((file) => {
                    fts.set(file, +virtualFiles[file].stats.mtime);
                });
            }
            callback();
        };
        if (compiler.hooks) {
            compiler.hooks.afterEnvironment.tap('VirtualModulesPlugin', afterEnvironmentHook);
            compiler.hooks.afterResolvers.tap('VirtualModulesPlugin', afterResolversHook);
            compiler.hooks.watchRun.tapAsync('VirtualModulesPlugin', watchRunHook);
        }
        else {
            compiler.plugin('after-environment', afterEnvironmentHook);
            compiler.plugin('after-resolvers', afterResolversHook);
            compiler.plugin('watch-run', watchRunHook);
        }
    }
}
var lib = VirtualModulesPlugin;

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var getFilename = () => fileURLToPath(import.meta.url);
var getDirname = () => require$$0$1.dirname(getFilename());
var __dirname = /* @__PURE__ */ getDirname();

// node_modules/.pnpm/@ampproject+remapping@1.0.2/node_modules/@ampproject/remapping/dist/remapping.mjs
var charToInteger = {};
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
for (i = 0; i < chars.length; i++) {
  charToInteger[chars.charCodeAt(i)] = i;
}
var i;
function decode(mappings) {
  var decoded = [];
  var line = [];
  var segment = [
    0,
    0,
    0,
    0,
    0
  ];
  var j = 0;
  for (var i = 0, shift = 0, value = 0; i < mappings.length; i++) {
    var c = mappings.charCodeAt(i);
    if (c === 44) {
      segmentify(line, segment, j);
      j = 0;
    } else if (c === 59) {
      segmentify(line, segment, j);
      j = 0;
      decoded.push(line);
      line = [];
      segment[0] = 0;
    } else {
      var integer = charToInteger[c];
      if (integer === void 0) {
        throw new Error("Invalid character (" + String.fromCharCode(c) + ")");
      }
      var hasContinuationBit = integer & 32;
      integer &= 31;
      value += integer << shift;
      if (hasContinuationBit) {
        shift += 5;
      } else {
        var shouldNegate = value & 1;
        value >>>= 1;
        if (shouldNegate) {
          value = value === 0 ? -2147483648 : -value;
        }
        segment[j] += value;
        j++;
        value = shift = 0;
      }
    }
  }
  segmentify(line, segment, j);
  decoded.push(line);
  return decoded;
}
function segmentify(line, segment, j) {
  if (j === 4)
    line.push([segment[0], segment[1], segment[2], segment[3]]);
  else if (j === 5)
    line.push([segment[0], segment[1], segment[2], segment[3], segment[4]]);
  else if (j === 1)
    line.push([segment[0]]);
}
function encode(decoded) {
  var sourceFileIndex = 0;
  var sourceCodeLine = 0;
  var sourceCodeColumn = 0;
  var nameIndex = 0;
  var mappings = "";
  for (var i = 0; i < decoded.length; i++) {
    var line = decoded[i];
    if (i > 0)
      mappings += ";";
    if (line.length === 0)
      continue;
    var generatedCodeColumn = 0;
    var lineMappings = [];
    for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {
      var segment = line_1[_i];
      var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);
      generatedCodeColumn = segment[0];
      if (segment.length > 1) {
        segmentMappings += encodeInteger(segment[1] - sourceFileIndex) + encodeInteger(segment[2] - sourceCodeLine) + encodeInteger(segment[3] - sourceCodeColumn);
        sourceFileIndex = segment[1];
        sourceCodeLine = segment[2];
        sourceCodeColumn = segment[3];
      }
      if (segment.length === 5) {
        segmentMappings += encodeInteger(segment[4] - nameIndex);
        nameIndex = segment[4];
      }
      lineMappings.push(segmentMappings);
    }
    mappings += lineMappings.join(",");
  }
  return mappings;
}
function encodeInteger(num) {
  var result = "";
  num = num < 0 ? -num << 1 | 1 : num << 1;
  do {
    var clamped = num & 31;
    num >>>= 5;
    if (num > 0) {
      clamped |= 32;
    }
    result += chars[clamped];
  } while (num > 0);
  return result;
}
function defaults(target, source) {
  return Object.assign(/* @__PURE__ */ Object.create(null), source, target);
}
function decodeSourceMap(map) {
  if (typeof map === "string") {
    map = JSON.parse(map);
  }
  let { mappings } = map;
  if (typeof mappings === "string") {
    mappings = sortMappings(decode(mappings), true);
  } else {
    mappings = sortMappings(mappings, false);
  }
  return defaults({ mappings }, map);
}
function firstUnsortedSegmentLine(mappings) {
  for (let i = 0; i < mappings.length; i++) {
    const segments = mappings[i];
    for (let j = 1; j < segments.length; j++) {
      if (segments[j][0] < segments[j - 1][0]) {
        return i;
      }
    }
  }
  return mappings.length;
}
function sortMappings(mappings, owned) {
  const unosrtedIndex = firstUnsortedSegmentLine(mappings);
  if (unosrtedIndex === mappings.length)
    return mappings;
  if (!owned)
    mappings = mappings.slice();
  for (let i = unosrtedIndex; i < mappings.length; i++) {
    mappings[i] = sortSegments(mappings[i], owned);
  }
  return mappings;
}
function sortSegments(segments, owned) {
  if (!owned)
    segments = segments.slice();
  return segments.sort(segmentComparator);
}
function segmentComparator(a, b) {
  return a[0] - b[0];
}
var OriginalSource = class {
  constructor(filename, content) {
    this.filename = filename;
    this.content = content;
  }
  traceSegment(line, column, name) {
    return { column, line, name, source: this };
  }
};
var Url = typeof URL !== "undefined" ? URL : __require("url").URL;
var parentRegex = /(^|\/)\.\.(?=\/|$)/g;
function isAbsoluteUrl(url) {
  try {
    return !!new Url(url);
  } catch (e) {
    return false;
  }
}
function uniqInStr(str) {
  let uniq = String(Math.random()).slice(2);
  while (str.indexOf(uniq) > -1) {
    uniq += uniq;
  }
  return uniq;
}
function stripPathFilename(path3) {
  path3 = normalizePath(path3);
  const index = path3.lastIndexOf("/");
  return path3.slice(0, index + 1);
}
function normalizeProtocolRelative(input, absoluteBase) {
  const { href, protocol } = new Url(input, absoluteBase);
  return href.slice(protocol.length);
}
function normalizeSimplePath(input) {
  const { href } = new Url(input, "https://foo.com/");
  return href.slice("https://foo.com/".length);
}
function normalizePath(input) {
  if (!parentRegex.test(input))
    return normalizeSimplePath(input);
  let total = 1;
  while (parentRegex.test(input))
    total++;
  const uniqDirectory = `z${uniqInStr(input)}/`;
  const search = new RegExp(`^(?:${uniqDirectory})*`);
  const relative = normalizeSimplePath(uniqDirectory.repeat(total) + input);
  return relative.replace(search, (all) => {
    const leftover = all.length / uniqDirectory.length;
    return "../".repeat(total - leftover);
  });
}
function resolve(input, base) {
  if (!base)
    base = "";
  if (isAbsoluteUrl(input))
    return new Url(input).href;
  if (base) {
    if (isAbsoluteUrl(base))
      return new Url(input, base).href;
    if (base.startsWith("//"))
      return normalizeProtocolRelative(input, `https:${base}`);
  }
  if (input.startsWith("//"))
    return normalizeProtocolRelative(input, "https://foo.com/");
  if (input.startsWith("/"))
    return "/" + normalizeSimplePath(input);
  const joined = stripPathFilename(base) + input;
  if (base.startsWith("/"))
    return "/" + normalizeSimplePath(joined);
  const relative = normalizePath(joined);
  if ((base || input).startsWith(".") && !relative.startsWith(".")) {
    return "./" + relative;
  }
  return relative;
}
function resolve$1(input, base) {
  if (base && !base.endsWith("/"))
    base += "/";
  return resolve(input, base);
}
function binarySearch(haystack, needle, comparator, low, high) {
  low = Math.max(low, 0);
  while (low <= high) {
    const mid = low + (high - low >> 1);
    const cmp = comparator(haystack[mid], needle);
    if (cmp === 0) {
      return mid;
    }
    if (cmp < 0) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  return ~low;
}
var FastStringArray = class {
  constructor() {
    this.indexes = /* @__PURE__ */ Object.create(null);
    this.array = [];
  }
  put(key) {
    const { array, indexes } = this;
    let index = indexes[key];
    if (index === void 0) {
      index = indexes[key] = array.length;
      array.push(key);
    }
    return index;
  }
};
var SourceMapTree = class {
  constructor(map, sources) {
    this.map = map;
    this.sources = sources;
    this.lastLine = 0;
    this.lastColumn = 0;
    this.lastIndex = 0;
  }
  traceMappings() {
    const mappings = [];
    const names = new FastStringArray();
    const sources = new FastStringArray();
    const sourcesContent = [];
    const { mappings: rootMappings, names: rootNames } = this.map;
    for (let i = 0; i < rootMappings.length; i++) {
      const segments = rootMappings[i];
      const tracedSegments = [];
      let lastTraced = void 0;
      for (let j = 0; j < segments.length; j++) {
        const segment = segments[j];
        if (segment.length === 1)
          continue;
        const source = this.sources[segment[1]];
        const traced = source.traceSegment(segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : "");
        if (!traced)
          continue;
        const { column, line, name } = traced;
        const { content, filename } = traced.source;
        const sourceIndex = sources.put(filename);
        sourcesContent[sourceIndex] = content;
        if (lastTraced && lastTraced[1] === sourceIndex && lastTraced[2] === line && lastTraced[3] === column) {
          continue;
        }
        if (name) {
          lastTraced = [segment[0], sourceIndex, line, column, names.put(name)];
        } else {
          lastTraced = [segment[0], sourceIndex, line, column];
        }
        tracedSegments.push(lastTraced);
      }
      mappings.push(tracedSegments);
    }
    return defaults({
      mappings,
      names: names.array,
      sources: sources.array,
      sourcesContent
    }, this.map);
  }
  traceSegment(line, column, name) {
    const { mappings, names } = this.map;
    if (line >= mappings.length)
      return null;
    const segments = mappings[line];
    if (segments.length === 0)
      return null;
    let low = 0;
    let high = segments.length - 1;
    if (line === this.lastLine) {
      if (column >= this.lastColumn) {
        low = this.lastIndex;
      } else {
        high = this.lastIndex;
      }
    }
    let index = binarySearch(segments, column, segmentComparator$1, low, high);
    this.lastLine = line;
    this.lastColumn = column;
    if (index === -1) {
      this.lastIndex = index;
      return null;
    }
    if (index < 0) {
      index = ~index - 1;
    }
    this.lastIndex = index;
    const segment = segments[index];
    if (segment.length === 1)
      return null;
    const source = this.sources[segment[1]];
    return source.traceSegment(segment[2], segment[3], segment.length === 5 ? names[segment[4]] : name);
  }
};
function segmentComparator$1(segment, column) {
  return segment[0] - column;
}
function stripFilename(path3) {
  if (!path3)
    return "";
  const index = path3.lastIndexOf("/");
  return path3.slice(0, index + 1);
}
function asArray(value) {
  if (Array.isArray(value))
    return value;
  return [value];
}
function buildSourceMapTree(input, loader, relativeRoot) {
  const maps = asArray(input).map(decodeSourceMap);
  const map = maps.pop();
  for (let i = 0; i < maps.length; i++) {
    if (maps[i].sources.length > 1) {
      throw new Error(`Transformation map ${i} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`);
    }
  }
  const { sourceRoot, sources, sourcesContent } = map;
  const children = sources.map((sourceFile, i) => {
    const uri = resolve$1(sourceFile || "", resolve$1(sourceRoot || "", stripFilename(relativeRoot)));
    const sourceMap = loader(uri);
    if (!sourceMap) {
      const sourceContent = sourcesContent ? sourcesContent[i] : null;
      return new OriginalSource(uri, sourceContent);
    }
    return buildSourceMapTree(decodeSourceMap(sourceMap), loader, uri);
  });
  let tree = new SourceMapTree(map, children);
  for (let i = maps.length - 1; i >= 0; i--) {
    tree = new SourceMapTree(maps[i], [tree]);
  }
  return tree;
}
var SourceMap = class {
  constructor(map, options) {
    this.version = 3;
    if ("file" in map)
      this.file = map.file;
    this.mappings = options.decodedMappings ? map.mappings : encode(map.mappings);
    this.names = map.names;
    this.sources = map.sources;
    if (!options.excludeContent && "sourcesContent" in map) {
      this.sourcesContent = map.sourcesContent;
    }
  }
  toString() {
    return JSON.stringify(this);
  }
};
function remapping(input, loader, options) {
  const opts = typeof options === "object" ? options : { excludeContent: !!options, decodedMappings: false };
  const graph = buildSourceMapTree(input, loader);
  return new SourceMap(graph.traceMappings(), opts);
}
var remapping_default = remapping;

// src/esbuild/utils.ts
var ExtToLoader = {
  ".js": "js",
  ".mjs": "js",
  ".cjs": "js",
  ".jsx": "jsx",
  ".ts": "ts",
  ".cts": "ts",
  ".mts": "ts",
  ".tsx": "tsx",
  ".css": "css",
  ".less": "css",
  ".stylus": "css",
  ".scss": "css",
  ".sass": "css",
  ".json": "json",
  ".txt": "text"
};
function guessLoader(id) {
  return ExtToLoader[extname(id).toLowerCase()] || "js";
}
function fixSourceMap(map) {
  if (!("toString" in map)) {
    Object.defineProperty(map, "toString", {
      enumerable: false,
      value: function toString() {
        return JSON.stringify(this);
      }
    });
  }
  if (!("toUrl" in map)) {
    Object.defineProperty(map, "toUrl", {
      enumerable: false,
      value: function toUrl() {
        return "data:application/json;charset=utf-8;base64," + Buffer.from(this.toString()).toString("base64");
      }
    });
  }
  return map;
}
var nullSourceMap = {
  names: [],
  sources: [],
  mappings: "",
  version: 3
};
function combineSourcemaps(filename, sourcemapList) {
  if (sourcemapList.length === 0 || sourcemapList.every((m) => m.sources.length === 0)) {
    return __spreadValues({}, nullSourceMap);
  }
  let map;
  let mapIndex = 1;
  const useArrayInterface = sourcemapList.slice(0, -1).find((m) => m.sources.length !== 1) === void 0;
  if (useArrayInterface) {
    map = remapping_default(sourcemapList, () => null, true);
  } else {
    map = remapping_default(sourcemapList[0], function loader(sourcefile) {
      if (sourcefile === filename && sourcemapList[mapIndex]) {
        return sourcemapList[mapIndex++];
      } else {
        return __spreadValues({}, nullSourceMap);
      }
    }, true);
  }
  if (!map.file) {
    delete map.file;
  }
  return map;
}

// src/esbuild/index.ts
function getEsbuildPlugin(factory) {
  return (userOptions) => {
    var _a, _b;
    const meta = {
      framework: "esbuild"
    };
    const plugin = factory(userOptions, meta);
    return {
      name: plugin.name,
      setup: (_b = (_a = plugin.esbuild) == null ? void 0 : _a.setup) != null ? _b : function setup({ onStart, onEnd, onResolve, onLoad }) {
        var _a2, _b2, _c, _d;
        const onResolveFilter = (_b2 = (_a2 = plugin.esbuild) == null ? void 0 : _a2.onResolveFilter) != null ? _b2 : /.*/;
        const onLoadFilter = (_d = (_c = plugin.esbuild) == null ? void 0 : _c.onLoadFilter) != null ? _d : /.*/;
        if (plugin.buildStart) {
          onStart(plugin.buildStart);
        }
        if (plugin.buildEnd) {
          onEnd(plugin.buildEnd);
        }
        if (plugin.resolveId) {
          onResolve({ filter: onResolveFilter }, async (args) => {
            const result = await plugin.resolveId(args.path, args.importer);
            if (typeof result === "string") {
              return { path: result, namespace: plugin.name };
            } else if (typeof result === "object" && result !== null) {
              return { path: result.id, external: result.external, namespace: plugin.name };
            }
          });
        }
        if (plugin.load || plugin.transform) {
          onLoad({ filter: onLoadFilter }, async (args) => {
            const errors = [];
            const warnings = [];
            const pluginContext = {
              error(message) {
                errors.push({ text: String(message) });
              },
              warn(message) {
                warnings.push({ text: String(message) });
              }
            };
            const resolveDir = require$$0$1.dirname(args.path);
            let code, map;
            if (plugin.load) {
              const result = await plugin.load.call(pluginContext, args.path);
              if (typeof result === "string") {
                code = result;
              } else if (typeof result === "object" && result !== null) {
                code = result.code;
                map = result.map;
              }
            }
            if (!plugin.transform) {
              if (code === void 0) {
                return null;
              }
              if (map) {
                if (!map.sourcesContent || map.sourcesContent.length === 0) {
                  map.sourcesContent = [code];
                }
                map = fixSourceMap(map);
                code += `
//# sourceMappingURL=${map.toUrl()}`;
              }
              return { contents: code, errors, warnings, loader: guessLoader(args.path), resolveDir };
            }
            if (!plugin.transformInclude || plugin.transformInclude(args.path)) {
              if (!code) {
                code = await fs.promises.readFile(args.path, "utf8");
              }
              const result = await plugin.transform.call(pluginContext, code, args.path);
              if (typeof result === "string") {
                code = result;
              } else if (typeof result === "object" && result !== null) {
                code = result.code;
                if (map && result.map) {
                  map = combineSourcemaps(args.path, [
                    result.map,
                    map
                  ]);
                } else {
                  map = result.map;
                }
              }
            }
            if (code) {
              if (map) {
                if (!map.sourcesContent || map.sourcesContent.length === 0) {
                  map.sourcesContent = [code];
                }
                map = fixSourceMap(map);
                code += `
//# sourceMappingURL=${map.toUrl()}`;
              }
              return { contents: code, errors, warnings, loader: guessLoader(args.path), resolveDir };
            }
          });
        }
      }
    };
  };
}

// src/rollup/index.ts
function getRollupPlugin(factory) {
  return (userOptions) => {
    const meta = {
      framework: "rollup"
    };
    const rawPlugin = factory(userOptions, meta);
    return toRollupPlugin(rawPlugin);
  };
}
function toRollupPlugin(plugin) {
  if (plugin.transform && plugin.transformInclude) {
    const _transform = plugin.transform;
    plugin.transform = function(code, id) {
      if (plugin.transformInclude && !plugin.transformInclude(id)) {
        return null;
      }
      return _transform.call(this, code, id);
    };
  }
  if (plugin.rollup) {
    Object.assign(plugin, plugin.rollup);
  }
  return plugin;
}

// src/vite/index.ts
function getVitePlugin(factory) {
  return (userOptions) => {
    const meta = {
      framework: "vite"
    };
    const rawPlugin = factory(userOptions, meta);
    const plugin = toRollupPlugin(rawPlugin);
    if (rawPlugin.vite) {
      Object.assign(plugin, rawPlugin.vite);
    }
    return plugin;
  };
}

// src/webpack/utils.ts
function slash(path3) {
  return path3.replace(/\\/g, "/");
}
function backSlash(path3) {
  return path3.replace(/\//g, "\\");
}

// src/webpack/index.ts
var _dirname = typeof __dirname !== "undefined" ? __dirname : dirname(fileURLToPath(import.meta.url));
var TRANSFORM_LOADER = resolve$3(_dirname, "webpack/loaders/transform.js");
var LOAD_LOADER = resolve$3(_dirname, "webpack/loaders/load.js");
function getWebpackPlugin(factory) {
  return (userOptions) => {
    return {
      apply(compiler) {
        var _a;
        const meta = {
          framework: "webpack",
          webpack: {
            compiler
          }
        };
        const virtualModulePrefix = resolve$3(process.cwd(), "_virtual_");
        const rawPlugin = factory(userOptions, meta);
        const plugin = Object.assign(rawPlugin, {
          __unpluginMeta: meta,
          __virtualModulePrefix: virtualModulePrefix
        });
        const injected = compiler.$unpluginContext || {};
        compiler.$unpluginContext = injected;
        injected[plugin.name] = plugin;
        compiler.hooks.thisCompilation.tap(plugin.name, (compilation) => {
          compilation.hooks.childCompiler.tap(plugin.name, (childCompiler) => {
            childCompiler.$unpluginContext = injected;
          });
        });
        if (plugin.transform) {
          compiler.options.module.rules.push({
            include(id) {
              if (id == null) {
                return false;
              }
              if (plugin.transformInclude) {
                return plugin.transformInclude(id);
              } else {
                return true;
              }
            },
            enforce: plugin.enforce,
            use: [{
              loader: TRANSFORM_LOADER,
              options: {
                unpluginName: plugin.name
              }
            }]
          });
        }
        if (plugin.resolveId) {
          let vfs = compiler.options.plugins.find((i) => i instanceof lib);
          if (!vfs) {
            vfs = new lib();
            compiler.options.plugins.push(vfs);
          }
          plugin.__vfsModules = /* @__PURE__ */ new Set();
          plugin.__vfs = vfs;
          const resolver = {
            apply(resolver2) {
              const target = resolver2.ensureHook("resolve");
              const tap = () => async (request, resolveContext, callback) => {
                if (!request.request) {
                  return callback();
                }
                const id = backSlash(request.request);
                if (id.startsWith(plugin.__virtualModulePrefix)) {
                  return callback();
                }
                const result = await plugin.resolveId(slash(id));
                if (result == null) {
                  return callback();
                }
                let resolved = typeof result === "string" ? result : result.id;
                if (!fs.existsSync(resolved)) {
                  resolved = plugin.__virtualModulePrefix + id;
                  plugin.__vfs.writeModule(resolved, "");
                  plugin.__vfsModules.add(resolved);
                }
                const newRequest = __spreadProps(__spreadValues({}, request), {
                  request: resolved
                });
                resolver2.doResolve(target, newRequest, null, resolveContext, callback);
              };
              resolver2.getHook("resolve").tapAsync("unplugin", tap());
            }
          };
          compiler.options.resolve.plugins = compiler.options.resolve.plugins || [];
          compiler.options.resolve.plugins.push(resolver);
        }
        if (plugin.load && plugin.__vfsModules) {
          compiler.options.module.rules.push({
            include(id) {
              return id != null && plugin.__vfsModules.has(id);
            },
            enforce: plugin.enforce,
            use: [{
              loader: LOAD_LOADER,
              options: {
                unpluginName: plugin.name
              }
            }]
          });
        }
        if (plugin.webpack) {
          plugin.webpack(compiler);
        }
        (_a = plugin.buildStart) == null ? void 0 : _a.call(plugin);
        if (plugin.buildEnd) {
          compiler.hooks.done.tapPromise(plugin.name, async () => {
            await plugin.buildEnd();
          });
        }
      }
    };
  };
}

// src/define.ts
function createUnplugin(factory) {
  return {
    get esbuild() {
      return getEsbuildPlugin(factory);
    },
    get rollup() {
      return getRollupPlugin(factory);
    },
    get vite() {
      return getVitePlugin(factory);
    },
    get webpack() {
      return getWebpackPlugin(factory);
    },
    get raw() {
      return factory;
    }
  };
}

const escapeRE = (str) => str.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
const RelativeAssetPlugin = function() {
  return {
    name: "nuxt:vite-relative-asset",
    generateBundle(_, bundle) {
      const generatedAssets = Object.entries(bundle).filter(([_2, asset]) => asset.type === "asset").map(([key]) => escapeRE(key));
      const assetRE = new RegExp(`\\/__NUXT_BASE__\\/(${generatedAssets.join("|")})`, "g");
      for (const file in bundle) {
        const asset = bundle[file];
        if (asset.type === "asset") {
          const depth = file.split("/").length - 1;
          const assetBase = depth === 0 ? "." : Array.from({ length: depth }).map(() => "..").join("/");
          asset.source = asset.source.toString().replace(assetRE, (r) => r.replace(/\/__NUXT_BASE__/g, assetBase));
          const publicBase = Array.from({ length: depth + 1 }).map(() => "..").join("/");
          asset.source = asset.source.toString().replace(/\/__NUXT_BASE__/g, publicBase);
        }
      }
    }
  };
};
const VITE_ASSET_RE = /^export default ["'](__VITE_ASSET.*)["']$/;
const DynamicBasePlugin = createUnplugin(function(options) {
  return {
    name: "nuxt:dynamic-base-path",
    resolveId(id) {
      if (id.startsWith("/__NUXT_BASE__")) {
        return id.replace("/__NUXT_BASE__", "");
      }
      return null;
    },
    enforce: "post",
    transform(code, id) {
      if (options.globalPublicPath && id.includes("entry.ts")) {
        code = `import { joinURL } from "ufo";${options.globalPublicPath} = joinURL(NUXT_BASE, NUXT_CONFIG.app.buildAssetsDir);` + code;
      }
      const assetId = code.match(VITE_ASSET_RE);
      if (assetId) {
        code = `import { joinURL } from "ufo";export default joinURL(NUXT_BASE, NUXT_CONFIG.app.buildAssetsDir, "${assetId[1]}".replace("/__NUXT_BASE__", ""));`;
      }
      if (code.includes("NUXT_BASE") && !code.includes("const NUXT_BASE =")) {
        code = "const NUXT_BASE = NUXT_CONFIG.app.cdnURL || NUXT_CONFIG.app.baseURL;" + code;
        if (options.env === "dev") {
          code = `const NUXT_CONFIG = { app: ${JSON.stringify(options.devAppConfig)} };` + code;
        } else if (options.env === "server") {
          code = 'import NUXT_CONFIG from "#config";' + code;
        } else {
          code = "const NUXT_CONFIG = __NUXT__.config;" + code;
        }
      }
      if (id === "vite/preload-helper") {
        code = code.replace(/const base = ['"]\/__NUXT_BASE__\/['"]/, 'import { joinURL } from "ufo";const base = joinURL(NUXT_BASE, NUXT_CONFIG.app.buildAssetsDir);');
      }
      code = code.replace(/from *['"]\/__NUXT_BASE__(\/[^'"]*)['"]/g, 'from "$1"');
      for (const delimiter of ["`", '"', "'"]) {
        const delimiterRE = new RegExp(`${delimiter}([^${delimiter}]*)\\/__NUXT_BASE__\\/([^${delimiter}]*)${delimiter}`, "g");
        code = code.replace(delimiterRE, "`$1${NUXT_BASE}$2`");
      }
      return code;
    }
  };
});

async function buildClient(ctx) {
  const clientConfig = vite.mergeConfig(ctx.config, {
    define: {
      "process.server": false,
      "process.client": true,
      "module.hot": false
    },
    resolve: {
      alias: {
        "#build/plugins": resolve$2(ctx.nuxt.options.buildDir, "plugins/client")
      }
    },
    build: {
      rollupOptions: {
        output: {
          chunkFileNames: ctx.nuxt.options.dev ? void 0 : "[name]-[hash].mjs",
          entryFileNames: ctx.nuxt.options.dev ? "entry.mjs" : "[name]-[hash].mjs"
        }
      },
      manifest: true,
      outDir: resolve$2(ctx.nuxt.options.buildDir, "dist/client")
    },
    plugins: [
      cacheDirPlugin(ctx.nuxt.options.rootDir, "client"),
      vuePlugin(ctx.config.vue),
      viteJsxPlugin(),
      DynamicBasePlugin.vite({ env: "client", devAppConfig: ctx.nuxt.options.app }),
      RelativeAssetPlugin(),
      devStyleSSRPlugin({
        rootDir: ctx.nuxt.options.rootDir,
        buildAssetsURL: joinURL(ctx.nuxt.options.app.baseURL, ctx.nuxt.options.app.buildAssetsDir)
      })
    ],
    server: {
      middlewareMode: true
    }
  });
  if (ctx.nuxt.options.build.analyze) {
    clientConfig.plugins.push(...analyzePlugin(ctx));
  }
  await ctx.nuxt.callHook("vite:extendConfig", clientConfig, { isClient: true, isServer: false });
  const viteServer = await vite.createServer(clientConfig);
  await ctx.nuxt.callHook("vite:serverCreated", viteServer);
  const viteMiddleware = (req, res, next) => {
    const originalURL = req.url;
    viteServer.middlewares.handle(req, res, (err) => {
      req.url = originalURL;
      next(err);
    });
  };
  await ctx.nuxt.callHook("server:devMiddleware", viteMiddleware);
  ctx.nuxt.hook("close", async () => {
    await viteServer.close();
  });
  if (!ctx.nuxt.options.dev) {
    const start = Date.now();
    await vite.build(clientConfig);
    await ctx.nuxt.callHook("build:resources", wpfs);
    consola.info(`Client built in ${Date.now() - start}ms`);
  }
  await writeManifest(ctx);
}

function isExternal(opts, id) {
  const ssrConfig = opts.viteServer.config.ssr;
  const externalOpts = {
    inline: [
      /virtual:/,
      /\.ts$/,
      ...ExternalsDefaults.inline,
      ...ssrConfig.noExternal
    ],
    external: [
      ...ssrConfig.external,
      /node_modules/
    ],
    resolve: {
      type: "module",
      extensions: [".ts", ".js", ".json", ".vue", ".mjs", ".jsx", ".tsx", ".wasm"]
    }
  };
  return isExternal$1(id, opts.viteServer.config.root, externalOpts);
}
async function transformRequest(opts, id) {
  if (id && id.startsWith("/@id/__x00__")) {
    id = "\0" + id.slice("/@id/__x00__".length);
  }
  if (id && id.startsWith("/@id/")) {
    id = id.slice("/@id/".length);
  }
  if (id && id.startsWith("/@fs/")) {
    id = id.slice("/@fs".length);
    if (id.match(/^\/\w:/)) {
      id = id.slice(1);
    }
  } else if (!id.includes("entry") && id.startsWith("/")) {
    const resolvedPath = resolve$2(opts.viteServer.config.root, "." + id);
    if (existsSync(resolvedPath)) {
      id = resolvedPath;
    }
  }
  const withoutVersionQuery = id.replace(/\?v=\w+$/, "");
  if (await isExternal(opts, withoutVersionQuery)) {
    const path = builtinModules.includes(withoutVersionQuery.split("node:").pop()) ? withoutVersionQuery : pathToFileURL(withoutVersionQuery);
    return {
      code: `(global, exports, importMeta, ssrImport, ssrDynamicImport, ssrExportAll) => import('${path}').then(r => { exports.default = r.default; ssrExportAll(r) }).catch(e => { console.error(e); throw new Error('[vite dev] Error loading external "${id}".') })`,
      deps: [],
      dynamicDeps: []
    };
  }
  const res = await opts.viteServer.transformRequest(id, { ssr: true }).catch((err) => {
    console.warn(`[SSR] Error transforming ${id}:`, err);
  }) || { code: "", map: {}, deps: [], dynamicDeps: [] };
  const code = `async function (global, __vite_ssr_exports__, __vite_ssr_import_meta__, __vite_ssr_import__, __vite_ssr_dynamic_import__, __vite_ssr_exportAll__) {
${res.code || "/* empty */"};
}`;
  return { code, deps: res.deps || [], dynamicDeps: res.dynamicDeps || [] };
}
async function transformRequestRecursive(opts, id, parent = "<entry>", chunks = {}) {
  if (chunks[id]) {
    chunks[id].parents.push(parent);
    return;
  }
  const res = await transformRequest(opts, id);
  const deps = uniq([...res.deps, ...res.dynamicDeps]);
  chunks[id] = {
    id,
    code: res.code,
    deps,
    parents: [parent]
  };
  for (const dep of deps) {
    await transformRequestRecursive(opts, dep, id, chunks);
  }
  return Object.values(chunks);
}
async function bundleRequest(opts, entryURL) {
  const chunks = await transformRequestRecursive(opts, entryURL);
  const listIds = (ids) => ids.map((id) => `// - ${id} (${hashId(id)})`).join("\n");
  const chunksCode = chunks.map((chunk) => `
// --------------------
// Request: ${chunk.id}
// Parents: 
${listIds(chunk.parents)}
// Dependencies: 
${listIds(chunk.deps)}
// --------------------
const ${hashId(chunk.id)} = ${chunk.code}
`).join("\n");
  const manifestCode = "const __modules__ = {\n" + chunks.map((chunk) => ` '${chunk.id}': ${hashId(chunk.id)}`).join(",\n") + "\n}";
  const ssrModuleLoader = `
const __pendingModules__ = new Map()
const __pendingImports__ = new Map()
const __ssrContext__ = { global: globalThis }

function __ssrLoadModule__(url, urlStack = []) {
  const pendingModule = __pendingModules__.get(url)
  if (pendingModule) { return pendingModule }
  const modulePromise = __instantiateModule__(url, urlStack)
  __pendingModules__.set(url, modulePromise)
  modulePromise.catch(() => { __pendingModules__.delete(url) })
         .finally(() => { __pendingModules__.delete(url) })
  return modulePromise
}

async function __instantiateModule__(url, urlStack) {
  const mod = __modules__[url]
  if (mod.stubModule) { return mod.stubModule }
  const stubModule = { [Symbol.toStringTag]: 'Module' }
  Object.defineProperty(stubModule, '__esModule', { value: true })
  mod.stubModule = stubModule
  // https://vitejs.dev/guide/api-hmr.html
  const importMeta = { url, hot: { accept() {}, prune() {}, dispose() {}, invalidate() {}, decline() {}, on() {} } }
  urlStack = urlStack.concat(url)
  const isCircular = url => urlStack.includes(url)
  const pendingDeps = []
  const ssrImport = async (dep) => {
    // TODO: Handle externals if dep[0] !== '.' | '/'
    if (!isCircular(dep) && !__pendingImports__.get(dep)?.some(isCircular)) {
      pendingDeps.push(dep)
      if (pendingDeps.length === 1) {
        __pendingImports__.set(url, pendingDeps)
      }
      await __ssrLoadModule__(dep, urlStack)
      if (pendingDeps.length === 1) {
        __pendingImports__.delete(url)
      } else {
        pendingDeps.splice(pendingDeps.indexOf(dep), 1)
      }
    }
    return __modules__[dep].stubModule
  }
  function ssrDynamicImport (dep) {
    // TODO: Handle dynamic import starting with . relative to url
    return ssrImport(dep)
  }

  function ssrExportAll(sourceModule) {
    for (const key in sourceModule) {
      if (key !== 'default') {
        try {
          Object.defineProperty(stubModule, key, {
            enumerable: true,
            configurable: true,
            get() { return sourceModule[key] }
          })
        } catch (_err) { }
      }
    }
  }

  await mod(
    __ssrContext__.global,
    stubModule,
    importMeta,
    ssrImport,
    ssrDynamicImport,
    ssrExportAll
  )

  return stubModule
}
`;
  const code = [
    chunksCode,
    manifestCode,
    ssrModuleLoader,
    `export default await __ssrLoadModule__('${entryURL}')`
  ].join("\n\n");
  return {
    code,
    ids: chunks.map((i) => i.id)
  };
}

async function buildServer(ctx) {
  const _resolve = (id) => resolveModule(id, { paths: ctx.nuxt.options.modulesDir });
  const serverConfig = vite.mergeConfig(ctx.config, {
    define: {
      "process.server": true,
      "process.client": false,
      "typeof window": '"undefined"',
      "typeof document": '"undefined"',
      "typeof navigator": '"undefined"',
      "typeof location": '"undefined"',
      "typeof XMLHttpRequest": '"undefined"'
    },
    resolve: {
      alias: {
        "#build/plugins": resolve$2(ctx.nuxt.options.buildDir, "plugins/server"),
        "vue/server-renderer": _resolve("vue/server-renderer"),
        "vue/compiler-sfc": _resolve("vue/compiler-sfc"),
        "@vue/reactivity": _resolve(`@vue/reactivity/dist/reactivity.cjs${ctx.nuxt.options.dev ? "" : ".prod"}.js`),
        "@vue/shared": _resolve(`@vue/shared/dist/shared.cjs${ctx.nuxt.options.dev ? "" : ".prod"}.js`),
        "vue-router": _resolve(`vue-router/dist/vue-router.cjs${ctx.nuxt.options.dev ? "" : ".prod"}.js`),
        vue: _resolve(`vue/dist/vue.cjs${ctx.nuxt.options.dev ? "" : ".prod"}.js`)
      }
    },
    ssr: {
      external: ["#config"],
      noExternal: [
        ...ctx.nuxt.options.build.transpile,
        /\/esm\/.*\.js$/,
        /\.(es|esm|esm-browser|esm-bundler).js$/,
        "/__vue-jsx",
        "#app",
        /nuxt3\/dist/,
        /nuxt3\/src/,
        /@nuxt\/nitro\/dist/,
        /@nuxt\/nitro\/src/
      ]
    },
    build: {
      outDir: resolve$2(ctx.nuxt.options.buildDir, "dist/server"),
      ssr: ctx.nuxt.options.ssr ?? true,
      rollupOptions: {
        output: {
          entryFileNames: "server.mjs",
          preferConst: true,
          format: "module"
        },
        onwarn(warning, rollupWarn) {
          if (!["UNUSED_EXTERNAL_IMPORT"].includes(warning.code)) {
            rollupWarn(warning);
          }
        }
      }
    },
    server: {
      preTransformRequests: false
    },
    plugins: [
      cacheDirPlugin(ctx.nuxt.options.rootDir, "server"),
      vuePlugin(ctx.config.vue),
      DynamicBasePlugin.vite({ env: ctx.nuxt.options.dev ? "dev" : "server", devAppConfig: ctx.nuxt.options.app }),
      viteJsxPlugin()
    ]
  });
  await ctx.nuxt.callHook("vite:extendConfig", serverConfig, { isClient: false, isServer: true });
  ctx.nuxt.hook("nitro:generate", async () => {
    const clientDist = resolve$2(ctx.nuxt.options.buildDir, "dist/client");
    const publicDir = join(ctx.nuxt.options.srcDir, ctx.nuxt.options.dir.public);
    let publicFiles = [];
    if (await isDirectory(publicDir)) {
      publicFiles = readDirRecursively(publicDir).map((r) => r.replace(publicDir, ""));
      for (const file of publicFiles) {
        try {
          fse.rmSync(join(clientDist, file));
        } catch {
        }
      }
    }
    if (await isDirectory(clientDist)) {
      const nestedAssetsPath = withoutTrailingSlash(join(clientDist, ctx.nuxt.options.app.buildAssetsDir));
      if (await isDirectory(nestedAssetsPath)) {
        await fse.copy(nestedAssetsPath, clientDist, { recursive: true });
        await fse.remove(nestedAssetsPath);
      }
    }
  });
  const onBuild = () => ctx.nuxt.callHook("build:resources", wpfs);
  if (!ctx.nuxt.options.dev) {
    const start = Date.now();
    consola.info("Building server...");
    await vite.build(serverConfig);
    await onBuild();
    consola.success(`Server built in ${Date.now() - start}ms`);
    return;
  }
  if (!ctx.nuxt.options.ssr) {
    await onBuild();
    return;
  }
  const viteServer = await vite.createServer(serverConfig);
  ctx.nuxt.hook("app:templatesGenerated", () => {
    for (const [id, mod] of viteServer.moduleGraph.idToModuleMap) {
      if (id.startsWith("\0virtual:")) {
        viteServer.moduleGraph.invalidateModule(mod);
      }
    }
  });
  ctx.nuxt.hook("close", () => viteServer.close());
  await viteServer.pluginContainer.buildStart({});
  const _doBuild = async () => {
    const start = Date.now();
    const { code, ids } = await bundleRequest({ viteServer }, resolve$2(ctx.nuxt.options.appDir, "entry"));
    await fse.writeFile(resolve$2(ctx.nuxt.options.buildDir, "dist/server/server.mjs"), code, "utf-8");
    await writeManifest(ctx, ids.filter(isCSS).map((i) => i.slice(1)));
    const time = Date.now() - start;
    consola.success(`Vite server built in ${time}ms`);
    await onBuild();
  };
  const doBuild = pDebounce(_doBuild, 100);
  await _doBuild();
  viteServer.watcher.on("all", (_event, file) => {
    file = normalize(file);
    if (file.indexOf(ctx.nuxt.options.buildDir) === 0) {
      return;
    }
    doBuild();
  });
  ctx.nuxt.hook("app:templatesGenerated", () => doBuild());
}

const PREFIX = "\0virtual:";
function virtual(vfs) {
  const extensions = ["", ".ts", ".vue", ".mjs", ".cjs", ".js", ".json"];
  const resolveWithExt = (id) => {
    for (const ext of extensions) {
      const rId = id + ext;
      if (rId in vfs) {
        return rId;
      }
    }
    return null;
  };
  return {
    name: "virtual",
    resolveId(id, importer) {
      if (process.platform === "win32" && isAbsolute(id)) {
        id = resolve$2(id);
      }
      const resolvedId = resolveWithExt(id);
      if (resolvedId) {
        return PREFIX + resolvedId;
      }
      if (importer && !isAbsolute(id)) {
        const importerNoPrefix = importer.startsWith(PREFIX) ? importer.slice(PREFIX.length) : importer;
        const importedDir = dirname$1(importerNoPrefix);
        const resolved = resolveWithExt(join(importedDir, id));
        if (resolved) {
          return PREFIX + resolved;
        }
      }
      return null;
    },
    load(id) {
      if (!id.startsWith(PREFIX)) {
        return null;
      }
      const idNoPrefix = id.slice(PREFIX.length);
      return {
        code: vfs[idNoPrefix],
        map: null
      };
    }
  };
}

async function warmupViteServer(server, entries) {
  const warmedUrls = /* @__PURE__ */ new Set();
  const warmup = async (url) => {
    if (warmedUrls.has(url)) {
      return void 0;
    }
    warmedUrls.add(url);
    try {
      await server.transformRequest(url);
    } catch (e) {
      consola.debug("Warmup for %s failed with: %s", url, e);
    }
    const deps = Array.from(server.moduleGraph.urlToModuleMap.get(url)?.importedModules || []);
    await Promise.all(deps.map((m) => warmup(m.url)));
  };
  await Promise.all(entries.map((entry) => warmup(entry)));
}

const distDir = dirname$1(fileURLToPath(import.meta.url));
resolve$2(distDir, "..");

function resolveCSSOptions(nuxt) {
  const css = {
    postcss: {
      plugins: []
    }
  };
  const plugins = defu(nuxt.options.build.postcss.postcssOptions.plugins, {
    "postcss-import": {
      resolve: createResolver({
        alias: { ...nuxt.options.alias },
        modules: [
          nuxt.options.srcDir,
          nuxt.options.rootDir,
          ...nuxt.options.modulesDir
        ]
      })
    },
    "postcss-url": {},
    autoprefixer: {}
  });
  for (const name in plugins) {
    const opts = plugins[name];
    if (!opts) {
      continue;
    }
    const plugin = requireModule(name, {
      paths: [
        ...nuxt.options.modulesDir,
        distDir
      ]
    });
    css.postcss.plugins.push(plugin(opts));
  }
  return css;
}

async function bundle(nuxt) {
  const ctx = {
    nuxt,
    config: vite.mergeConfig({
      root: nuxt.options.srcDir,
      mode: nuxt.options.dev ? "development" : "production",
      logLevel: "warn",
      define: {
        "process.dev": nuxt.options.dev
      },
      resolve: {
        extensions: [".mjs", ".js", ".ts", ".jsx", ".tsx", ".json", ".vue"],
        alias: {
          ...nuxt.options.alias,
          "#app": nuxt.options.appDir,
          "#build/plugins": "",
          "#build": nuxt.options.buildDir,
          "/entry.mjs": resolve$2(nuxt.options.appDir, "entry"),
          "web-streams-polyfill/ponyfill/es2018": "unenv/runtime/mock/empty",
          "abort-controller": "unenv/runtime/mock/empty"
        }
      },
      base: nuxt.options.dev ? joinURL(nuxt.options.app.baseURL, nuxt.options.app.buildAssetsDir) : "/__NUXT_BASE__/",
      publicDir: resolve$2(nuxt.options.srcDir, nuxt.options.dir.public),
      vue: {
        isProduction: !nuxt.options.dev,
        template: { compilerOptions: nuxt.options.vue.compilerOptions }
      },
      css: resolveCSSOptions(nuxt),
      optimizeDeps: {
        exclude: [
          ...nuxt.options.build.transpile.filter((i) => typeof i === "string"),
          "vue-demi"
        ],
        entries: [
          resolve$2(nuxt.options.appDir, "entry.ts")
        ]
      },
      esbuild: {
        jsxFactory: "h",
        jsxFragment: "Fragment",
        tsconfigRaw: "{}"
      },
      clearScreen: false,
      build: {
        assetsDir: nuxt.options.dev ? withoutLeadingSlash(nuxt.options.app.buildAssetsDir) : ".",
        emptyOutDir: false,
        rollupOptions: {
          input: resolve$2(nuxt.options.appDir, "entry"),
          output: { sanitizeFileName: sanitizeFilePath }
        }
      },
      plugins: [
        virtual(nuxt.vfs)
      ],
      server: {
        fs: {
          strict: false,
          allow: [
            nuxt.options.buildDir,
            nuxt.options.appDir,
            nuxt.options.srcDir,
            nuxt.options.rootDir,
            ...nuxt.options.modulesDir
          ]
        }
      }
    }, nuxt.options.vite || {})
  };
  await nuxt.callHook("vite:extend", ctx);
  nuxt.hook("vite:serverCreated", (server) => {
    const start = Date.now();
    warmupViteServer(server, ["/entry.mjs"]).then(() => {
      consola.info(`Vite warmed up in ${Date.now() - start}ms`);
    }).catch(consola.error);
  });
  await buildClient(ctx);
  await buildServer(ctx);
}

export { bundle };
