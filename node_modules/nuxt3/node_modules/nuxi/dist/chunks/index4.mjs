import require$$0$3 from 'http';
import require$$6 from 'https';
import { promisify } from 'util';
import require$$0, { promises } from 'fs';
import { networkInterfaces } from 'os';
import { h as gray, b as cyan, u as underline, i as bold } from './index.mjs';
import require$$0$2 from 'net';
import require$$0$1 from 'path';
import { d as defu } from './kit.mjs';
import 'tty';
import 'assert';
import './index2.mjs';
import './cjs.mjs';
import 'module';
import 'url';

var dist$1 = {};

var dist = {};

Object.defineProperty(dist, '__esModule', { value: true });

const fs = require$$0;
const path = require$$0$1;

const _memo = {
  _pid: process.pid
};
async function getMemo(config) {
  const options = getOptions(config);
  try {
    const memo = JSON.parse(await fs.promises.readFile(options.file, "utf-8")) || {};
    if (!memo._pid) {
      throw new Error("Memo lacks _pid");
    }
    if (memo._pid === _memo._pid || !isAlive(memo.pid)) {
      Object.assign(_memo, memo);
      _memo._pid = process.pid;
    }
  } catch (e) {
  }
  return _memo;
}
async function setMemo(memo, config) {
  const options = getOptions(config);
  Object.assign(_memo, memo);
  _memo._pid = process.pid;
  try {
    await fs.promises.mkdir(options.dir);
  } catch (e) {
  }
  try {
    await fs.promises.writeFile(options.file, JSON.stringify(_memo), "utf-8");
  } catch (e) {
  }
}
function getOptions(config) {
  const options = {...config};
  options.name = options.name || "default";
  options.dir = options.dir || path.resolve(process.cwd(), "node_modules/.cache/fs-memo");
  options.file = options.file || path.resolve(options.dir, options.name + ".json");
  return options;
}
function isAlive(pid) {
  try {
    process.kill(pid, 0);
    return true;
  } catch (e) {
    return e.code === "EPERM";
  }
}

dist.getMemo = getMemo;
dist.setMemo = setMemo;

Object.defineProperty(dist$1, '__esModule', { value: true });

const net = require$$0$2;
const fsMemo = dist;

async function getPort(config) {
  if (typeof config === "number" || typeof config === "string") {
    config = {port: parseInt(config + "")};
  }
  const options = {
    name: "default",
    random: false,
    port: parseInt(process.env.PORT || "") || 3e3,
    ports: [4e3, 5e3, 6e3, 7e3],
    host: process.env.HOST || "0.0.0.0",
    memoName: "port",
    ...config
  };
  const portsToCheck = [];
  if (!options.random) {
    if (options.port) {
      portsToCheck.push(options.port);
    }
    if (Array.isArray(options.ports)) {
      portsToCheck.push(...options.ports);
    }
  }
  const memoOptions = {name: options.memoName, dir: options.memoDir};
  const memoKey = "port_" + options.name;
  const memo = await fsMemo.getMemo(memoOptions);
  if (memo[memoKey]) {
    portsToCheck.push(memo[memoKey]);
  }
  const availablePort = await checkPorts(portsToCheck, options.host);
  await fsMemo.setMemo({[memoKey]: availablePort}, memoOptions);
  return availablePort;
}
async function checkPorts(ports, host) {
  for (const port of ports) {
    const r = await checkPort(port, host);
    if (r) {
      return r;
    }
  }
  return checkPort(0, host);
}
function checkPort(port, host) {
  return new Promise((resolve) => {
    const server = net.createServer();
    server.unref();
    server.on("error", () => {
      resolve(false);
    });
    server.listen(port, host, () => {
      const {port: port2} = server.address();
      server.close(() => {
        resolve(port2);
      });
    });
  });
}

var getPort_1 = dist$1.getPort = getPort;

var httpShutdown = {exports: {}};

(function (module, exports) {
var http = require$$0$3;
var https = require$$6;

/**
 * Expose `addShutdown`.
 */
exports = module.exports = addShutdown;

/**
 * Adds shutdown functionaility to the `http.Server` object
 * @param {http.Server} server The server to add shutdown functionaility to
 */
function addShutdown(server) {
  var connections = {};
  var isShuttingDown = false;
  var connectionCounter = 0;

  function destroy(socket, force) {
    if (force || (socket._isIdle && isShuttingDown)) {
      socket.destroy();
      delete connections[socket._connectionId];
    }
  }
  function onConnection(socket) {
    var id = connectionCounter++;
    socket._isIdle = true;
    socket._connectionId = id;
    connections[id] = socket;

    socket.on('close', function() {
      delete connections[id];
    });
  }
  server.on('request', function(req, res) {
    req.socket._isIdle = false;

    res.on('finish', function() {
      req.socket._isIdle = true;
      destroy(req.socket);
    });
  });

  server.on('connection', onConnection);
  server.on('secureConnection', onConnection);

  function shutdown(force, cb) {
    isShuttingDown = true;
    server.close(function(err) {
      if (cb) {
        process.nextTick(function() { cb(err); });
      }
    });

    Object.keys(connections).forEach(function(key) {
      destroy(connections[key], force);
    });
  }
  server.shutdown = function(cb) {
    shutdown(false, cb);
  };

  server.forceShutdown = function(cb) {
    shutdown(true, cb);
  };

  return server;
}
/**
 * Extends the {http.Server} object with shutdown functionaility.
 * @return {http.Server} The decorated server object
 */
exports.extend = function() {
  http.Server.prototype.withShutdown = function() {
    return addShutdown(this);
  };

  https.Server.prototype.withShutdown = function() {
    return addShutdown(this);
  };
};
}(httpShutdown, httpShutdown.exports));

const addShutdown = httpShutdown.exports;

async function listen(handle, opts = {}) {
  opts = defu(opts, {
    port: process.env.PORT || 3e3,
    hostname: process.env.HOST || "0.0.0.0",
    showURL: true,
    baseURL: "/",
    open: false,
    clipboard: false,
    isTest: process.env.NODE_ENV === "test",
    isProd: process.env.NODE_ENV === "production",
    autoClose: true
  });
  if (opts.isTest) {
    opts.showURL = false;
  }
  if (opts.isProd || opts.isTest) {
    opts.open = false;
    opts.clipboard = false;
  }
  const port = await getPort_1(opts.port);
  let server;
  let url;
  const isExternal = opts.hostname === "0.0.0.0";
  const displayHost = isExternal ? "localhost" : opts.hostname;
  if (opts.https) {
    const { key, cert } = opts.certificate ? await resolveCert(opts.certificate) : await getSelfSignedCert(opts.selfsigned);
    server = require$$6.createServer({ key, cert }, handle);
    addShutdown(server);
    await promisify(server.listen.bind(server))(port, opts.host);
    url = `https://${displayHost}:${port}${opts.baseURL}`;
  } else {
    server = require$$0$3.createServer(handle);
    addShutdown(server);
    await promisify(server.listen.bind(server))(port, opts.host);
    url = `http://${displayHost}:${port}${opts.baseURL}`;
  }
  let _closed = false;
  const close = () => {
    if (_closed) {
      return Promise.resolve();
    }
    _closed = true;
    return promisify(server.shutdown)();
  };
  if (opts.clipboard) {
    const clipboardy = await import('./browser.mjs').then((r) => r.default || r);
    await clipboardy.write(url).catch(() => {
      opts.clipboard = false;
    });
  }
  const showURL = () => {
    const add = opts.clipboard ? gray("(copied to clipboard)") : "";
    const lines = [];
    lines.push(`  > Local:    ${formatURL(url)} ${add}`);
    if (isExternal) {
      for (const ip of getExternalIps()) {
        lines.push(`  > Network:  ${formatURL(url.replace("localhost", ip))}`);
      }
    }
    console.log("\n" + lines.join("\n") + "\n");
  };
  if (opts.showURL) {
    showURL();
  }
  const _open = async () => {
    const { default: open } = await import('./index5.mjs').then(function (n) { return n.i; });
    await open(url).catch(() => {
    });
  };
  if (opts.open) {
    await _open();
  }
  if (opts.autoClose) {
    process.on("exit", () => close());
  }
  return {
    url,
    server,
    open: _open,
    showURL,
    close
  };
}
async function resolveCert(input) {
  const key = await promises.readFile(input.key, "utf-8");
  const cert = await promises.readFile(input.cert, "utf-8");
  return { key, cert };
}
async function getSelfSignedCert(opts = {}) {
  const { generate } = await import('./index6.mjs').then(function (n) { return n.i; });
  const { private: key, cert } = await promisify(generate)(opts.attrs, opts);
  return { key, cert };
}
function getExternalIps() {
  const ips = /* @__PURE__ */ new Set();
  for (const details of Object.values(networkInterfaces())) {
    if (details) {
      for (const d of details) {
        if (d.family === "IPv4" && !d.internal) {
          ips.add(d.address);
        }
      }
    }
  }
  return Array.from(ips);
}
function formatURL(url) {
  return cyan(underline(decodeURI(url).replace(/:(\d+)\//g, `:${bold("$1")}/`)));
}

export { listen };
