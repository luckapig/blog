import { promises } from 'fs';
import { r as resolve, j as join } from './index2.mjs';
import { c as createServer } from './server.mjs';
import { l as loadKit, w as writeTypes } from './kit.mjs';
import { c as clearDir } from './fs.mjs';
import { d as defineNuxtCommand } from './index.mjs';
import 'path';
import './cjs.mjs';
import 'module';
import 'url';
import 'util';
import './rimraf.mjs';
import 'assert';
import 'tty';
import 'os';

const TRAILING_SLASH_RE = /\/$|\/\?/;
function hasTrailingSlash(input = "", queryParams = false) {
  if (!queryParams) {
    return input.endsWith("/");
  }
  return TRAILING_SLASH_RE.test(input);
}
function withoutTrailingSlash(input = "", queryParams = false) {
  if (!queryParams) {
    return (hasTrailingSlash(input) ? input.slice(0, -1) : input) || "/";
  }
  if (!hasTrailingSlash(input, true)) {
    return input || "/";
  }
  const [s0, ...s] = input.split("?");
  return (s0.slice(0, -1) || "/") + (s.length ? `?${s.join("?")}` : "");
}
function promisifyHandle(handle) {
  return function(req, res) {
    return callHandle(handle, req, res);
  };
}
function callHandle(handle, req, res) {
  return new Promise((resolve, reject) => {
    const next = (err) => err ? reject(err) : resolve(void 0);
    try {
      const returned = handle(req, res, next);
      if (returned !== void 0) {
        resolve(returned);
      } else {
        res.once("close", next);
        res.once("error", next);
      }
    } catch (err) {
      next(err);
    }
  });
}
function lazyHandle(handle, promisify) {
  let _promise;
  const resolve = () => {
    if (!_promise) {
      _promise = Promise.resolve(handle()).then((r) => promisify ? promisifyHandle(r.default || r) : r.default || r);
    }
    return _promise;
  };
  return function(req, res) {
    return resolve().then((h) => h(req, res));
  };
}

const MIMES = {
  html: "text/html",
  json: "application/json"
};

const defer = typeof setImmediate !== "undefined" ? setImmediate : (fn) => fn();
function send(res, data, type) {
  if (type) {
    defaultContentType(res, type);
  }
  return new Promise((resolve) => {
    defer(() => {
      res.end(data);
      resolve(void 0);
    });
  });
}
function defaultContentType(res, type) {
  if (type && !res.getHeader("Content-Type")) {
    res.setHeader("Content-Type", type);
  }
}

class H3Error extends Error {
  constructor() {
    super(...arguments);
    this.statusCode = 500;
    this.statusMessage = "H3Error";
  }
}
function createError(input) {
  var _a;
  if (input instanceof H3Error) {
    return input;
  }
  const err = new H3Error((_a = input.message) != null ? _a : input.statusMessage);
  if (input.statusCode) {
    err.statusCode = input.statusCode;
  }
  if (input.statusMessage) {
    err.statusMessage = input.statusMessage;
  }
  if (input.data) {
    err.data = input.data;
  }
  return err;
}
function sendError(res, error, debug) {
  let h3Error;
  if (error instanceof H3Error) {
    h3Error = error;
  } else {
    console.error(error);
    h3Error = createError(error);
  }
  if (res.writableEnded) {
    return;
  }
  res.statusCode = h3Error.statusCode;
  res.statusMessage = h3Error.statusMessage;
  const responseBody = {
    statusCode: res.statusCode,
    statusMessage: res.statusMessage,
    stack: [],
    data: h3Error.data
  };
  if (debug) {
    responseBody.stack = (h3Error.stack || "").split("\n").map((l) => l.trim());
  }
  res.setHeader("Content-Type", MIMES.json);
  res.end(JSON.stringify(responseBody, null, 2));
}

function createApp(options = {}) {
  const stack = [];
  const _handle = createHandle(stack, options);
  const app = function(req, res) {
    return _handle(req, res).catch((error) => {
      if (options.onError) {
        return options.onError(error, req, res);
      }
      return sendError(res, error, !!options.debug);
    });
  };
  app.stack = stack;
  app._handle = _handle;
  app.use = (arg1, arg2, arg3) => use(app, arg1, arg2, arg3);
  return app;
}
function use(app, arg1, arg2, arg3) {
  if (Array.isArray(arg1)) {
    arg1.forEach((i) => use(app, i, arg2, arg3));
  } else if (Array.isArray(arg2)) {
    arg2.forEach((i) => use(app, arg1, i, arg3));
  } else if (typeof arg1 === "string") {
    app.stack.push(normalizeLayer({ ...arg3, route: arg1, handle: arg2 }));
  } else if (typeof arg1 === "function") {
    app.stack.push(normalizeLayer({ ...arg2, route: "/", handle: arg1 }));
  } else {
    app.stack.push(normalizeLayer({ ...arg1 }));
  }
  return app;
}
function createHandle(stack, options) {
  const spacing = options.debug ? 2 : void 0;
  return async function handle(req, res) {
    req.originalUrl = req.originalUrl || req.url || "/";
    const reqUrl = req.url || "/";
    for (const layer of stack) {
      if (layer.route.length > 1) {
        if (!reqUrl.startsWith(layer.route)) {
          continue;
        }
        req.url = reqUrl.slice(layer.route.length) || "/";
      } else {
        req.url = reqUrl;
      }
      if (layer.match && !layer.match(req.url, req)) {
        continue;
      }
      const val = await layer.handle(req, res);
      if (res.writableEnded) {
        return;
      }
      const type = typeof val;
      if (type === "string") {
        return send(res, val, MIMES.html);
      } else if (type === "object" && val !== void 0) {
        if (val && val.buffer) {
          return send(res, val);
        } else if (val instanceof Error) {
          throw createError(val);
        } else {
          return send(res, JSON.stringify(val, null, spacing), MIMES.json);
        }
      }
    }
    if (!res.writableEnded) {
      throw createError({ statusCode: 404, statusMessage: "Not Found" });
    }
  };
}
function normalizeLayer(layer) {
  if (layer.promisify === void 0) {
    layer.promisify = layer.handle.length > 2;
  }
  return {
    route: withoutTrailingSlash(layer.route),
    match: layer.match,
    handle: layer.lazy ? lazyHandle(layer.handle, layer.promisify) : layer.promisify ? promisifyHandle(layer.handle) : layer.handle
  };
}

const analyze = defineNuxtCommand({
  meta: {
    name: "analyze",
    usage: "npx nuxi analyze [rootDir]",
    description: "Build nuxt and analyze production bundle (experimental)"
  },
  async invoke(args) {
    process.env.NODE_ENV = process.env.NODE_ENV || "production";
    const rootDir = resolve(args._[0] || ".");
    const statsDir = join(rootDir, ".nuxt/stats");
    const { loadNuxt, buildNuxt } = await loadKit(rootDir);
    const analyzeOptions = {
      template: "treemap",
      projectRoot: rootDir,
      filename: join(statsDir, "{name}.html")
    };
    const nuxt = await loadNuxt({
      rootDir,
      config: {
        build: {
          analyze: analyzeOptions
        }
      }
    });
    await clearDir(nuxt.options.buildDir);
    await writeTypes(nuxt);
    await buildNuxt(nuxt);
    const app = createApp();
    const server = createServer(app);
    const serveFile = (filePath) => lazyHandle(async () => {
      const contents = await promises.readFile(filePath, "utf-8");
      return (_req, res) => {
        res.end(contents);
      };
    });
    console.warn("Do not deploy analyze results! Use `nuxi build` before deployng.");
    console.info("Starting stats server...");
    app.use("/client", serveFile(join(statsDir, "client.html")));
    app.use("/nitro", serveFile(join(statsDir, "nitro.html")));
    app.use(() => `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Nuxt Bundle Stats (experimental)</title>
</head>
  <h1>Nuxt Bundle Stats (experimental)</h1>
  <ul>
    <li>
      <a href="/nitro">Nitro server bundle stats</a>
    </li>
    <li>
      <a href="/client">Client bundle stats</a>
    </li>
  </ul>
</html>`);
    await server.listen();
  }
});

export { analyze as default };
